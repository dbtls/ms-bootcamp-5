# 09/15 회고록

## DAO, Repository, Entity, DTO, VO 정리

### 1. DAO (Data Access Object)
- 데이터베이스 접근 로직만을 전담하는 객체
- 애플리케이션 코드에서 DB 쿼리를 직접 다루지 않고 DAO를 통해 간접적으로 처리

#### 특징
- 기술 중심 계층: SQL 작성, DB 연결, ResultSet 처리.
- 주된 책임: CRUD(Create, Read, Update, Delete).
- 비즈니스 로직 없이 오직 데이터 읽기, 쓰기, 수정 등만 처리
- DB관리 문법을 Java코드내에 그대로 사용하기에 DB 벤더 교체시 수정사항이 많아짐

```java
public class EmpDAO {
    // 추가
    public boolean insertEmp(EmpDTO empDTO) {
        String sql = "insert into emp(ename, job, mgr, hiredate, sal, comm, deptno) values(?,?,?,?,?,?,?)";
        boolean resultFlag = false;
        try (
                Connection conn = DBUtil.getConnection();
                PreparedStatement ps = conn.prepareStatement(sql);
        ) {
            ps.setString(1, empDTO.getEname());
            ps.setString(2, empDTO.getJob());
            ps.setInt(3, empDTO.getMgr());
            ps.setDate(4, empDTO.getHiredate());
            ps.setDouble(5, empDTO.getSal());
            ps.setDouble(6, empDTO.getComm());
            ps.setInt(7, empDTO.getDeptno());

            int resultCount = ps.executeUpdate();
            if (resultCount == 1) {
                resultFlag = true;
                System.out.println("입력성공!!");
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
        return resultFlag;
    }
    // 전체 조회
    public List<EmpDTO> getEmpList() {
        List<EmpDTO> empList = new ArrayList<EmpDTO>();
        String sql = "select empno, ename, job, mgr, hiredate, sal, comm, deptno from emp";

        try (
                Connection conn = DBUtil.getConnection();
                PreparedStatement ps = conn.prepareStatement(sql);
                ResultSet rs = ps.executeQuery();
        ) {
            while (rs.next()) {
                EmpDTO empDTO = new EmpDTO();
                empDTO.setEmpno(rs.getInt(1));
                empDTO.setEname(rs.getString(2));
                empDTO.setJob(rs.getString(3));
                empDTO.setMgr(rs.getInt(4));
                empDTO.setHiredate(rs.getDate(5));
                empDTO.setSal(rs.getDouble(6));
                empDTO.setComm(rs.getDouble(7));
                empDTO.setDeptno(rs.getInt(8));

                empList.add(empDTO);
            }
        } catch (Exception e) {
            System.out.println(e.getMessage());
        }
        return empList;
    }
```

### 2. Repository
- DAO 개념을 도메인 중심으로 추상화한 저장소.
- “어떻게 가져올까?”(SQL)가 아니라 “무엇을 가져올까?”(도메인 객체)가 중심

#### 특징
- 도메인 주도 설계(DDD)에서 차용된 개념.
- 엔티티 단위로 저장/조회 기능을 제공.
- Spring Data JPA 같은 ORM 프레임워크에서 자동 구현 가능.

코드 예시 (Spring Data JPA)
```java
public interface UserRepository extends JpaRepository<User, Long> {
    Optional<User> findByEmail(String email);
    Optional<User> findById(Long id);
    Optional<User> findByUsername(String username);
    Page<User> findAllByRole(Role role, Pageable pageable);
}
```
#### JPA
- Spring Data JPA는 메서드 명을 통해 쿼리 자동 생성
- findBy필드명(+조건)
- 연결 키워드: And, Or, Between 등

예시
```java
Optional<User> findByEmail(String email);
// SELECT u FROM User u WHERE u.email = :email

Optional<User> findById(Long id);
// SELECT u FROM User u WHERE u.id = :id

Optional<User> findByUsername(String username);
// SELECT u FROM User u WHERE u.username = :username

Page<User> findAllByRole(Role role, Pageable pageable);
// SELECT u FROM User u WHERE u.role = :role
// SELECT COUNT(u) FROM User u WHERE u.role = :role

```
- 규칙만 지키면 SQL 작성 없이도 자동 쿼리 생성.
- 쿼리문을 감추는 장점이 SQL 세부 제어가 어려운 단점이 되기도 함

### 3. Entity
- DB 테이블과 1:1로 매핑되는 도메인 모델
- 간단한 비즈니스 로직 포함 가능 (불변식 검증, 상태 전환, 계산 등).

코드 예시
```java
@Entity
public class Order {
    @Id @GeneratedValue
    private Long id;
    private int quantity;
    private int price;
    private OrderStatus status;

    protected Order() {} // JPA 기본 생성자

    public Order(int quantity, int price) {
        if (quantity <= 0) throw new IllegalArgumentException("수량은 1 이상");
        this.quantity = quantity;
        this.price = price;
        this.status = OrderStatus.CREATED;
    }

    public int totalPrice() {
        return quantity * price;
    }

    public void pay() {
        if (status != OrderStatus.CREATED) throw new IllegalStateException("결제 불가");
        this.status = OrderStatus.PAID;
   1111 }
}
```
- 빈 껍데기 엔티티(Getter/Setter만 있는 빈약한 도메인 모델) 지양.


### 4. DTO (Data Transfer Object)
- 계층 간, 네트워크 간 데이터 전송을 위해 설계된 객체
- 엔티티를 그대로 노출하지 않고 데이터를 전송하기 위해 사용
- 순수 데이터 전달용: getter/setter 만 존재
- 비즈니스 로직 없음.


```java
public class UserRequestDTO {
    private String name;
    private int age;
    // getter/setter
}

public class UserResponseDTO {
    private Long id;
    private String name;

    public static UserResponseDTO from(User entity) {
        UserResponseDTO dto = new UserResponseDTO();
        dto.id = entity.getId();
        dto.name = entity.getName();
        return dto;
    }
}
```
- responseDTO는 꼭 필요한 데이터만 포함시키기


### 5. VO (Value Object)
- 특정 개념의 ‘값’ 자체를 표현하는 객체
- 두 VO가 같으면 “그 값이 같다”라고 판단
- equals/hashCode 반드시 구현
- 불변(immutable) 객체로 설계.

코드 예시
```java
@Embeddable
public class Money {
    private int amount;
    private String currency;

    protected Money() {} // JPA용

    private Money(int amount, String currency) {
        if (amount < 0) throw new IllegalArgumentException("음수 금액 불가");
        this.amount = amount;
        this.currency = currency;
    }

    public static Money of(int amount, String currency) {
        return new Money(amount, currency);
    }

    public Money add(Money other) {
        if (!this.currency.equals(other.currency)) throw new IllegalArgumentException("통화 불일치");
        return Money.of(this.amount + other.amount, currency);
    }

    @Override
    public boolean equals(Object o) { /* 값 기준 비교 */ }
    @Override
    public int hashCode() { /* 값 기준 해시 */ }
}
```

### 요약
- DAO vs Repository: 같은 저장소 계층이지만, DAO는 기술(SQL), Repository는 도메인(Entity) 중심.
- Entity: DB와 매핑되는 도메인 객체. 객체의 행위를 나타내는 비즈니스 로직 포함 가능.
- DTO: 계층 간 또는 네트워크 간 데이터 전달용 객체. 엔티티를 외부에 직접 노출하지 말고 DTO로 전달해야함.
- VO: 값 자체를 표현하는 객체. 불변성과 동등성 보장이 핵심.