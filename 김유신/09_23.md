# 09/23 회고록

## JavaScript 기초 정리

## 2. 변수와 상수

#### 2-1. 변수 선언 (let)

```js
let age = 25;
age = 30; // 재할당 가능
```

- 블록 스코프(block scope) 가짐.

- 자바의 지역변수와 비슷하지만, 함수 스코프 개념도 존재.

#### 2-2. 상수 선언 (const)

```js
const PI = 3.14;
// PI = 3.14159;
```

- 재할당 불가능.

- 단, 객체나 배열은 참조 유지 -> 내부 값 수정 가능.

#### 2-3. var

```js
if (true) {
  var x = 10;
}
console.log(x); // 10 (블록 밖에서도 접근 가능!)
```

- 함수 스코프만 존재 -> 블록 스코프가 없어 버그 유발.
- 호이스팅(Hoisting) 문제 때문에 현대 JS에서는 사용 지양.

## 3. 데이터 타입

### 3-1. 숫자 (Number)

```jsx
let a = 42;
let b = 3.14;
let c = "문자열" / 2; // NaN
```

- 정수/실수 구분 없음 → 전부 Number 타입.
- 특별한 값: `Infinity`, `Infinity`, `NaN`.

### 3-2. 문자열 (String)

```jsx
let name = "홍길동";
console.log(`안녕하세요, ${name}님!`);
```

- 작은따옴표, 큰따옴표, 백틱 모두 사용 가능.
- 백틱(`) 사용 시 **템플릿 리터럴** → 변수/표현식 삽입 가능.

### 3-3. 불리언 (Boolean)

- `true`, `false` 두 가지 값.
- 조건문에서 Truthy/Falsy 변환과 함께 자주 쓰임.

### 3-4. null과 undefined

```jsx
let x; // undefined
let y = null; // null
```

- `null`: 값이 없음을 명시적으로 지정.
- `undefined`: 변수 선언 후 값이 아직 정의되지 않음.

## 4. 연산자

### 4-1. 산술 연산자

```jsx
let x = 10;
let y = 3;
console.log(x + y); // 13
console.log(x % y); // 1
덧셈, 뺄셈, 곱셈, 나눗셈, 나머지 모두 사용 가능.

문자열 + 숫자 시 자동 형변환 발생: "5" + 1 → "51".
```

### 4-2. 비교 연산자

```jsx
console.log(5 == "5"); // true
console.log(5 === "5"); // false
```

- `==` : 값만 비교(자동 형변환 허용).
- `===` : 값 + 타입 비교(권장).

### 4-3. 논리 연산자

```jsx
true && false; // false
true || false; // true
!true; // false
```

- 단축 평가(Short-circuit) 동작 존재.
- `a || b` → a가 truthy면 b는 평가하지 않음.

### 4-4. 삼항 연산자

```jsx
let age = 20;
let msg = age >= 18 ? "성인" : "미성년자";
console.log(msg); // "성인"
```

- 조건식 ? 참일 때 값 : 거짓일 때 값

### 5. 조건문

### 5-1. if문

```jsx
let score = 85;
if (score >= 90) {
  console.log("A");
} else if (score >= 80) {
  console.log("B");
} else {
  console.log("C");
}
```

- 기본 구조는 자바와 동일.
- 조건식에 **Truthy/Falsy** 값도 사용 가능 (`0, "", null, undefined, NaN` → false 취급).

### 5-2. switch문

```jsx
let day = 2;
switch (day) {
  case 1:
    console.log("월요일");
    break;
  case 2:
    console.log("화요일");
    break;
  default:
    console.log("기타 요일");
}
```

- `break` 없으면 아래 case도 연속 실행(fall-through).
- `switch(true)` 패턴으로 조건문 대체 가능.

## 6. 함수

### 6-1. 함수 선언

```jsx
function add(a, b) {
  return a + b;
}
console.log(add(2, 3)); // 5
```

- function 키워드로 선언.
- 자바와 달리 반환 타입을 명시하지 않음.
- 함수 선언문은 호이스팅되어, 정의 전에 호출해도 실행 가능.

### 6-2. 화살표 함수

```jsx
const square = (x) => x * x;
console.log(square(5)); // 25
```

- ES6부터 추가된 간단한 함수 표현식.
- 중괄호·`return` 생략 가능(단일 표현식일 경우).
- 자신만의 `this`를 갖지 않고 **외부 스코프의 this**를 사용.

### 6-3. 실습: 성적 계산기

```jsx
function grade(score) {
  return score >= 90 ? "A" : score >= 80 ? "B" : score >= 70 ? "C" : "F";
}
console.log(grade(85)); // "B"
```

- 삼항 연산자를 중첩해 간단히 성적 등급 계산.
- 화살표 함수로도 동일하게 작성 가능.

## 7. 객체

### 7-1. 객체 생성과 접근

```jsx
const person = {
  name: "홍길동",
  age: 25,
};
console.log(person.name); // "홍길동"
console.log(person["age"]); // 25
```

- `{}` 리터럴로 생성.
- 점 표기법 또는 대괄호 표기법으로 속성 접근.

### 7-2. 객체 메서드

```jsx
const user = {
  name: "철수",
  greet() {
    console.log(`안녕하세요, ${this.name}입니다.`);
  },
};
user.greet(); // "안녕하세요, 철수입니다."
```

- 객체 안의 함수 = 메서드.
- `this`는 해당 객체를 가리킴.

### 7-3. 객체 구조 분해

```jsx
const { name, age } = person;
console.log(name); // "홍길동"
console.log(age); // 25
```

- 객체의 속성을 변수로 쉽게 꺼내옴.
- 기본값 지정 가능: `{nickname = "없음"}`.

### 7-4. Getter와 Setter

```jsx
const account = {
  _balance: 0,
  get balance() {
    return this._balance;
  },
  set balance(value) {
    if (value >= 0) this._balance = value;
  },
};
account.balance = 1000;
console.log(account.balance); // 1000
```

- `get` / `set` 키워드로 프로퍼티 접근 제어.
- 외부에서는 필드처럼 보이지만 내부적으로 메서드 실행.

### 7-5. this 바인딩

```jsx
function showThis() {
  console.log(this);
}
showThis(); // 전역 객체(window/global)

const obj = { show: showThis };
obj.show(); // obj
```

- 호출 방식에 따라 `this` 값이 달라짐.
- 화살표 함수는 `this`를 바인딩하지 않고 외부 스코프 것을 사용.

## 8. 배열

### 8-1. 배열 기초

```jsx
let arr = [1, 2, 3];
arr.push(4); // [1,2,3,4]
arr.pop(); // [1,2,3]
console.log(arr.length); // 3
```

- 크기가 동적으로 변하는 배열.
- `push`/`pop` → 뒤에서 추가/제거.

### 8-2. 배열 메서드 - 기본

```jsx
let fruits = ["사과", "바나나"];
fruits.unshift("포도"); // ["포도","사과","바나나"]
fruits.shift(); // ["사과","바나나"]
```

- `unshift`/`shift` → 앞에서 추가/제거.

### 8-3. 스프레드 연산자와 구조 분해

```jsx
let arr1 = [1, 2];
let arr2 = [...arr1, 3, 4];
console.log(arr2); // [1,2,3,4]

let [a, b] = arr1;
console.log(a, b); // 1 2
```

- `...` 스프레드 연산자는 배열을 펼쳐 복사/합치기에 사용.
- 구조 분해 할당으로 배열 요소를 변수로 추출 가능.

### 8-4. 배열 메서드 - 고급

**forEach**

```jsx
[1, 2, 3].forEach((n) => console.log(n));
// 1, 2, 3 출력
```

- 단순 반복 처리, 반환값 없음.

**map**

```jsx
let squares = [1, 2, 3].map((n) => n * n);
console.log(squares); // [1,4,9]
```

- 각 요소 변환 → 새로운 배열 반환.

**filter**

```jsx
let evens = [1, 2, 3, 4].filter((n) => n % 2 === 0);
console.log(evens); // [2,4]
```

- 조건에 맞는 요소만 추출.

**reduce**

```jsx
let sum = [1, 2, 3].reduce((acc, cur) => acc + cur, 0);
console.log(sum); // 6
```

- 누적 계산 → 단일 값 반환.

**find / findIndex**

```jsx
let nums = [10, 20, 30];
console.log(nums.find((n) => n > 15)); // 20
console.log(nums.findIndex((n) => n > 15)); // 1
```

- 조건을 만족하는 첫 번째 요소/인덱스 반환.

**splice / slice**

```jsx
let arr = [1, 2, 3, 4];
arr.splice(1, 2); // [2,3] 제거 → arr=[1,4]
console.log(arr);

console.log(arr.slice(0, 2)); // [1,2] (원본 유지)
```

- `splice` → 원본 배열 수정.
- `slice` → 복사본 반환.

**concat / join**

```jsx
console.log([1, 2].concat([3, 4])); // [1,2,3,4]
console.log(["a", "b"].join("-")); // "a-b"
```

- `concat` 배열 합치기.
- `join` 배열 → 문자열 변환.

**indexOf / includes**

```jsx
let letters = ["a", "b", "c"];
console.log(letters.indexOf("b")); // 1
console.log(letters.includes("c")); // true
```

- `indexOf` → 인덱스 위치 반환.
- `includes` → 존재 여부 true/false.
