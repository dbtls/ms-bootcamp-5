# 09/25 회고록

# 자바스크립트 - 이벤트

## 1. DOM과 이벤트 기본 개념

### 1-1. DOM

- **DOM (Document Object Model)** = 브라우저가 웹페이지(HTML)를 해석해서 만든 **트리 구조 객체 모델**
- HTML 문서의 각 요소(`<div>`, `<p>`, `<button>`, …)가 **노드(node)** 로 표현됨
- 자바스크립트는 이 DOM을 조작해서 화면의 내용을 바꾸거나, 이벤트를 붙일 수 있음

- 예시 :

  ```html
  <html>
    <body>
      <button id="btn">클릭!</button>
    </body>
  </html>
  ```

  **위 코드의 DOM 트리 :**

  ```
  Document
  └─ html
      └─ body
          └─ button (id="btn")

  ```

- DOM은 **웹페이지의 구조를 코드(객체)로 표현한 것**

### 1-2. 이벤트란?

- **이벤트(Event)** = DOM 요소에서 발생하는 사건
- 예: 마우스 클릭, 키보드 입력, 스크롤, 텍스트 입력, 폼 제출 등
- 브라우저가 이런 사건을 감지하면, 우리가 등록해둔 **리스너(listener, 이벤트 핸들러)** 를 실행

### 1-3. 이벤트 리스너 등록 방법

1. **HTML 속성 직접 작성 (DOM0 방식)**

```html
<button onclick="alert('클릭!')">클릭</button>
```

간단하지만 유지보수 어려움. 지금은 잘 안 씀.

1. **자바스크립트에서 속성 할당**

```jsx
const btn = document.getElementById("btn");
btn.onclick = () => {
  alert("클릭됨!");
};
```

한 번만 등록 가능 (마지막에 등록한 함수가 덮어씀)

1. **addEventListener 사용 (권장 방식)**

```jsx
const btn = document.getElementById("btn");
btn.addEventListener("click", () => {
  alert("클릭됨!");
});
```

장점:

- 같은 이벤트에 여러 개의 리스너 등록 가능
- 캡처링/버블링 제어 옵션 제공

### 1-4. 이벤트 객체 (Event Object)

- 이벤트가 발생하면, 브라우저는 자동으로 **이벤트 객체**를 핸들러 함수에 전달

```jsx
btn.addEventListener("click", (event) => {
  console.log(event.type); // "click"
  console.log(event.target); // 실제 클릭된 요소 <button>
});
```

**주요 속성**

- `event.type`: 이벤트 종류
- `event.target`: 이벤트가 발생한 실제 요소
- `event.currentTarget`: 리스너가 붙어 있는 요소
- `event.defaultPrevented`: 기본 동작이 막혔는지 여부

### 1-5. 요약

- DOM: HTML 문서를 브라우저가 해석해 만든 **객체 트리**
- 이벤트: DOM 요소에서 발생하는 사건
- 이벤트 리스너: `onclick`보다 **`addEventListener`** 권장
- 이벤트 객체: 이벤트 정보(타입, 타깃 등)를 담아 자동 전달

## 2. 이벤트 흐름(전파) 메커니즘

### 2-1. 이벤트 전파란?

- 이벤트는 **DOM 트리**를 따라 이동하며 발생
- 버튼 클릭 시, 버튼뿐 아니라 상위 요소에도 이벤트가 전달됨
- 이 과정을 **이벤트 전파(Event Propagation)** 라고 함

### 2-2. 이벤트 전파 단계

1. **캡처링 단계**: 문서 최상위에서 타깃까지 내려옴
2. **타깃 단계**: 실제 이벤트가 발생한 요소에서 실행
3. **버블링 단계**: 다시 부모 방향으로 올라가며 실행

- 대부분의 이벤트는 3단계를 모두 거침

- `focus`, `blur` 등 일부 이벤트는 버블링 안 함

### 2-3. target vs currentTarget

```html
<div id="parent">
  <button id="child">클릭</button>
</div>
```

```jsx
document.getElementById("parent").addEventListener("click", (event) => {
  console.log("target:", event.target); // 버튼
  console.log("currentTarget:", event.currentTarget); // div
});
```

- `event.target`: 실제 이벤트가 발생한 요소
- `event.currentTarget`: 리스너가 붙은 요소

### 2-4. 이벤트 전파 제어

- `event.stopPropagation()`: 부모로 더 전파되지 않음
- `event.stopImmediatePropagation()`: 같은 요소의 다른 리스너도 실행 안 함
- `event.preventDefault()`: 전파를 막는 게 아니라 **브라우저의 기본 동작**을 막음 (예: 링크 이동, 폼 제출 등)

### 2-5. 예시 — 클릭 전파

```html
<div id="outer">
  <div id="inner">
    <button id="btn">클릭</button>
  </div>
</div>
```

```jsx
document.getElementById("outer").addEventListener("click", () => {
  console.log("outer div");
});
document.getElementById("inner").addEventListener("click", () => {
  console.log("inner div");
});
document.getElementById("btn").addEventListener("click", () => {
  console.log("button");
});
```

**버튼 클릭 시 출력**

```
button
inner div
outer div

```

### 2-6. 요약

- 이벤트 전파: **캡처링 → 타깃 → 버블링**
- `target`: 실제 이벤트 발생 요소
- `currentTarget`: 리스너가 붙은 요소
- 전파 제어: `stopPropagation`, `preventDefault`

## 3. 이벤트 등록과 관리

### 3-1. addEventListener

```jsx
element.addEventListener(type, listener, options);
```

- type: `"click"`, `"keydown"` 등
- listener: 실행할 함수
- options: true/false 또는 객체

### 3-2. 옵션 객체

```jsx
element.addEventListener("click", handler, {
  capture: false,
  once: true,
  passive: true,
});
```

- **capture**: true면 캡처링 단계 실행
- **once**: 한 번만 실행 후 자동 해제
- **passive**: true면 `preventDefault()` 무시 → 스크롤 성능 최적화

### 3-3. removeEventListener

같은 함수 참조를 넘겨야 해제 가능.

```jsx
function handler(e) {
  console.log("클릭");
}

btn.addEventListener("click", handler);
btn.removeEventListener("click", handler); // 해제
```

익명 함수로는 해제 불가:

```jsx
btn.addEventListener("click", () => console.log("클릭"));
// removeEventListener 불가
```

### 3-4. 메모리 관리

- 리스너는 참조를 유지 → 필요 없으면 해제해야 함
- SPA나 동적 DOM 환경에서는 **메모리 누수** 주의
- `once: true` 옵션도 활용 가능

### 3-5. 이벤트 위임 (Event Delegation)

- 버블링을 활용 → 상위 요소에 리스너 하나만 등록

```html
<ul id="list">
  <li>사과</li>
  <li>바나나</li>
  <li>포도</li>
</ul>
```

```jsx
const list = document.getElementById("list");
list.addEventListener("click", (e) => {
  if (e.target.tagName === "LI") {
    console.log("과일:", e.target.textContent);
  }
});
```

- 장점: 동적으로 추가된 요소에도 자동 적용, 성능 최적화

# JAVA - 쓰레드

## 1. 쓰레드의 기본 개념

### 1-1. 프로세스와 쓰레드의 차이

- **프로세스(Process)**: 실행 중인 하나의 프로그램, 독립적인 메모리 공간(Code, Data, Heap, Stack)을 가짐.
- **쓰레드(Thread)**: 프로세스 내에서 실행되는 흐름 단위, Code/Data/Heap은 공유하고 Stack만 독립적으로 가짐.
- 프로세스 간은 메모리를 공유하지 않지만, 쓰레드 간은 공유 가능.

### 1-2. 자바에서 쓰레드가 필요한 이유

- 자바는 멀티쓰레드 프로그래밍을 지원하도록 설계됨.
- GUI 이벤트 처리, 서버의 동시 요청 처리, 파일 I/O·네트워크 통신과 같은 비동기 작업에서 활용됨.

### 1-3. 멀티쓰레드의 장점

- CPU 활용 극대화 (멀티코어 환경에서 병렬 처리 가능)
- 응답성 향상 (UI가 멈추지 않음)
- 자원 공유 비용이 적음 (같은 메모리 공간 활용)

### 1-4. 멀티쓰레드의 단점

- 동기화 문제: Race Condition 발생 가능
- 디버깅 어려움: 실행 순서가 일정하지 않음
- 컨텍스트 스위칭 비용 발생

## 2. Thread 클래스와 Runnable 인터페이스

### 2-1. Thread 클래스 상속 방식

- `Thread`를 상속받아 `run()`을 오버라이드하고, `start()` 호출로 실행.

```java
class MyThread extends Thread {
    public void run() {
        System.out.println("Thread 실행: " + Thread.currentThread().getName());
    }
}

public class Example {
    public static void main(String[] args) {
        MyThread t = new MyThread();
        t.start();
    }
}

```

### 2-2. Runnable 인터페이스 구현 방식

- `Runnable`을 구현한 객체를 `Thread`에 전달.
- 다중 상속 문제를 피할 수 있어 더 권장되는 방식.

```java
class MyTask implements Runnable {
    public void run() {
        System.out.println("Runnable 실행: " + Thread.currentThread().getName());
    }
}

public class Example {
    public static void main(String[] args) {
        Thread t = new Thread(new MyTask());
        t.start();
    }
}

```

### 2-3. 람다식 활용

- `Runnable`은 함수형 인터페이스이므로 람다로 간단히 작성 가능.

```java
Thread t = new Thread(() -> System.out.println("람다식 실행"));
t.start();

```

### 2-4. start() vs run()

- `start()`: 새로운 쓰레드를 생성하고 내부적으로 `run()` 호출.
- `run()`: 단순 메서드 호출, 새로운 쓰레드가 생성되지 않음.

```java
Thread t = new Thread(() -> System.out.println("Hello"));
t.run();   // 메인 쓰레드에서 실행
t.start(); // 별도 쓰레드에서 실행

```

## 3. 동기화 (Synchronization)

### 3-1. 동기화 필요성

- 여러 쓰레드가 공유 자원에 동시에 접근하면 **Race Condition** 발생 가능.
- 실행 순서에 따라 결과가 달라져 프로그램의 신뢰성을 해칠 수 있음.

### 3-2. synchronized 키워드

- 임계 구역(Critical Section)에 대해 락(Lock)을 걸어 하나의 쓰레드만 접근 가능하게 함.

```java
class Counter {
    private int count = 0;

    public synchronized void increment() {
        count++;
    }
}

```

### 3-3. 동기화 블록

- 메서드 전체가 아니라 필요한 부분만 동기화 가능.

```java
public void increment() {
    synchronized(this) {
        count++;
    }
}

```

### 3-4. 모니터(Monitor)와 락(Lock)

- 자바의 모든 객체는 내부적으로 모니터를 가짐.
- `synchronized`를 쓰면 모니터 락을 기반으로 동기화를 보장.

### 3-5. 예시

```java
public class SyncExample {
    public static void main(String[] args) throws InterruptedException {
        Counter counter = new Counter();

        Runnable task = () -> {
            for (int i = 0; i < 1000; i++) counter.increment();
        };

        Thread t1 = new Thread(task);
        Thread t2 = new Thread(task);

        t1.start();
        t2.start();
        t1.join();
        t2.join();

        System.out.println("최종 count = " + counter.getCount());
    }
}

```

- `synchronized` 없이 실행 시 결과가 불안정.
- `synchronized` 적용 시 항상 기대한 값이 보장됨.
