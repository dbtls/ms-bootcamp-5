# 09/30 회고록

## 1. 스트림

### 1-1. 스트림의 개념과 필요성

- 스트림(Stream)은 **데이터 처리의 추상화된 흐름**
- 컬렉션 데이터를 반복문보다 더 **간결하고 직관적**으로 처리 가능
- 특징
  - **더 나은 데이터 처리**: 필터링, 매핑, 집계 등을 한 줄 코드로 작성
  - **함수형 프로그래밍 지원**: 람다식과 함께 활용
  - **병렬 처리 용이**: `parallelStream()`만으로 멀티코어 활용 가능

### 1-2. 스트림과 컬렉션의 차이

| 구분             | 컬렉션(Collection)            | 스트림(Stream)                |
| ---------------- | ----------------------------- | ----------------------------- |
| 데이터 저장 여부 | 메모리에 데이터 저장          | 데이터 저장 X (흐름만 처리)   |
| 처리 방식        | 외부 반복(External Iteration) | 내부 반복(Internal Iteration) |
| 계산 방식        | 즉시 계산                     | 지연 계산(Lazy Evaluation)    |
| 재사용성         | 여러 번 사용 가능             | 한 번만 사용 가능             |
| 병렬 처리        | 직접 구현 필요                | parallelStream() 지원         |

## 2. 스트림 생성과 활용

### 2-1. 다양한 소스에서 스트림 생성

- **컬렉션** → `list.stream()`, `set.stream()`
- **배열** → `Arrays.stream(array)`
- **Stream.of()** → 직접 값 나열
- **무한 스트림** → `Stream.iterate()`, `Stream.generate()`
- **파일** → `Files.lines(Paths.get("data.txt"))`

### 2-2. 중간 연산과 최종 연산

- **중간 연산** (스트림 반환, 이어붙일 수 있음)
  - `filter`, `map`, `sorted`, `distinct`, `peek`
- **최종 연산** (스트림 소비, 결과 반환)
  - `collect`, `forEach`, `reduce`, `count`, `min`, `max`

**예제**

```java
List<String> result = names.stream()
    .filter(name -> name.length() > 3)  // 중간 연산
    .map(String::toUpperCase)           // 중간 연산
    .sorted()                           // 중간 연산
    .collect(Collectors.toList());      // 최종 연산

```

## 3. 데이터 필터링과 변환

### 3-1. 필터링: filter, distinct

- **filter**: 조건에 맞는 요소만 추림
- **distinct**: 중복 요소 제거

```java
List<Integer> evenNumbers = numbers.stream()
    .filter(n -> n % 2 == 0)
    .collect(Collectors.toList()); // 짝수만

```

```java
List<String> uniqueWords = words.stream()
    .distinct()
    .collect(Collectors.toList()); // 중복 없는 단어

```

### 3-2. 변환: map, flatMap

- **map**: 요소를 다른 값으로 변환 (ex: 문자열 → 대문자, 문자열 길이)
- **flatMap**: 중첩된 스트림을 평탄화 (ex: List<List<T>> → List<T>)

```java
List<String> upper = names.stream()
    .map(String::toUpperCase)
    .toList(); // [ALICE, BOB, CHARLIE]

```

```java
List<String> flat = nested.stream()
    .flatMap(Collection::stream)
    .toList(); // 2차원 리스트 → 1차원 리스트

```

## 4. 정렬과 순회

### 4-1. 정렬: sorted

- **기본 정렬**: 자연 순서(Comparable 구현 기준)
- **커스텀 정렬**: `Comparator` 사용 가능

```java
List<String> sorted = fruits.stream()
    .sorted(Comparator.reverseOrder()) // 내림차순
    .toList();

```

### 4-2. 순회: forEach, peek

- **forEach**: 최종 연산, 요소 반복 처리
- **peek**: 중간 연산, 디버깅용으로 값 확인

```java
numbers.stream()
    .peek(n -> System.out.println("원본: " + n))
    .map(n -> n * 2)
    .peek(n -> System.out.println("두 배: " + n))
    .toList();

```

## 5. Optional

### 5-1. Optional의 개념

- `Optional<T>`는 **null 안전**을 보장하기 위한 컨테이너 객체
- 값이 있을 수도(`present`), 없을 수도(`empty`) 있는 상황에서 `null` 대신 사용
- `NullPointerException` 방지 + 가독성 향상

### 5-2. Optional 만들기

```java
Optional<String> opt1 = Optional.of("Hello");     // null 불가
Optional<String> opt2 = Optional.ofNullable(null); // null 허용
Optional<String> opt3 = Optional.empty();          // 빈 Optional

```

### 5-3. 값 다루기

```java
Optional<String> opt = Optional.of("Hi");

// 값이 있으면 실행
opt.ifPresent(val -> System.out.println("값: " + val));

// 값이 없으면 기본값
String result = opt.orElse("기본값"); // Hi

// 값이 없으면 예외 발생
String must = opt.orElseThrow(() -> new IllegalArgumentException("값 없음"));

```

### 5-4. map과 flatMap

- `map`: Optional 안의 값을 꺼내서 변환 후 다시 Optional로 반환
- `flatMap`: 변환 결과가 이미 Optional이면 **중첩 방지**

```java
Optional<String> opt = Optional.of("hello");

Optional<Integer> len = opt.map(String::length);
// Optional[5]

Optional<String> upper = opt.flatMap(s -> Optional.of(s.toUpperCase()));
// Optional[HELLO]

```

## 6. 매칭과 검색

### 6-1. 조건 매칭

스트림에서 **조건 검사**를 간단히 수행할 수 있음.

```java
List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5);

// 모든 요소가 양수인가?
boolean allPositive = numbers.stream().allMatch(n -> n > 0); // true

// 하나라도 짝수가 있는가?
boolean hasEven = numbers.stream().anyMatch(n -> n % 2 == 0); // true

// 음수가 하나도 없는가?
boolean noNegative = numbers.stream().noneMatch(n -> n < 0); // true

```

- `allMatch`: 모든 요소가 조건을 만족해야 true
- `anyMatch`: 하나라도 조건 만족 시 true
- `noneMatch`: 모든 요소가 조건 불만족 시 true

### 6-2. 요소 검색

조건에 맞는 요소를 반환 (Optional로 감싸짐)

```java
List<String> names = Arrays.asList("Alice", "Bob", "Charlie", "David");

// 첫 번째 요소 찾기
Optional<String> first = names.stream().findFirst();
// Optional[Alice]

// 아무 요소 찾기 (병렬 처리에서 유용)
Optional<String> any = names.parallelStream().findAny();
// Optional[랜덤 요소]

```

**포인트**

- `findFirst`: 순서가 중요한 경우 사용
- `findAny`: 순서 상관없이 빠른 결과 원할 때 (병렬 스트림에서 최적화)

## 7. 집계 연산

### 7-1. 기본 집계

스트림의 결과를 하나의 값으로 요약할 수 있음.

```java
List<Integer> numbers = Arrays.asList(3, 7, 2, 9, 1, 5, 8, 4, 6);

long count = numbers.stream().count(); // 요소 개수 → 9

Optional<Integer> min = numbers.stream().min(Integer::compareTo); // 최소값 → 1
Optional<Integer> max = numbers.stream().max(Integer::compareTo); // 최대값 → 9

```

- `count`: 요소 개수 반환
- `min` / `max`: Optional로 감싸서 반환 (값이 없을 수 있음)

### 7-2. 숫자 스트림 집계

박싱/언박싱 비용 줄이려면 **기본형 스트림(IntStream, LongStream, DoubleStream)** 사용 권장.

```java
List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5);

// 합계
int sum = numbers.stream().mapToInt(Integer::intValue).sum(); // 15

// 평균
double avg = numbers.stream().mapToInt(Integer::intValue).average().orElse(0.0); // 3.0

// 종합 통계
IntSummaryStatistics stats = numbers.stream()
    .mapToInt(Integer::intValue)
    .summaryStatistics();

System.out.println(stats);
// count=5, sum=15, min=1, average=3.0, max=5

```

- `sum`, `average`, `min`, `max` 등을 제공
- `summaryStatistics()`로 한 번에 요약 가능

## 8. 리듀싱과 수집

### 8-1. reduce (축약)

스트림의 요소를 하나의 값으로 축약.

```java
List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5);

// 합계 (초기값 있음)
int sum = numbers.stream()
    .reduce(0, (a, b) -> a + b); // 15

// 합계 (메서드 참조)
int sum2 = numbers.stream()
    .reduce(0, Integer::sum); // 15

// 최댓값 (초기값 없음 → Optional 반환)
Optional<Integer> max = numbers.stream()
    .reduce(Integer::max); // Optional[5]

```

- 초기값을 주면 일반 값 반환
- 초기값을 안 주면 `Optional<T>`로 반환
- 결합법칙이 성립하는 연산에 적합 (합, 곱, 최댓값 등)

### 8-2. collect (수집)

스트림 결과를 컬렉션, 맵, 문자열로 모음.

```java
List<Student> students = Arrays.asList(
    new Student("Alice", 85, "CS"),
    new Student("Bob", 92, "Math"),
    new Student("Charlie", 78, "CS")
);

// toList
List<String> names = students.stream()
    .map(Student::getName)
    .collect(Collectors.toList());

// toSet
Set<String> depts = students.stream()
    .map(Student::getDepartment)
    .collect(Collectors.toSet());

// toMap
Map<String, Integer> nameToScore = students.stream()
    .collect(Collectors.toMap(Student::getName, Student::getScore));

// joining
String allNames = students.stream()
    .map(Student::getName)
    .collect(Collectors.joining(", "));
// "Alice, Bob, Charlie"

```

- `toList`, `toSet`, `toMap` → 자료구조로 변환
- `joining` → 문자열 결합
- `groupingBy`, `partitioningBy` 같은 고급 수집도 제공

## 9. 그룹화와 분할

### 9-1. groupingBy (그룹화)

키 함수를 기준으로 그룹핑.

```java
Map<String, List<Employee>> byDept = employees.stream()
    .collect(Collectors.groupingBy(Employee::getDepartment));

```

- 키: 부서명
- 값: 그 부서의 직원 리스트

**그룹별 집계**

```java
Map<String, Double> avgSalary = employees.stream()
    .collect(Collectors.groupingBy(
        Employee::getDepartment,
        Collectors.averagingDouble(Employee::getSalary)
    ));

```

**다단계 그룹화**

```java
Map<String, Map<Boolean, List<Employee>>> complex =
    employees.stream()
        .collect(Collectors.groupingBy(
            Employee::getDepartment,
            Collectors.partitioningBy(e -> e.getSalary() > 4500)
        ));

```

### 9-2. partitioningBy (분할)

불리언 조건으로 두 구획(true/false)으로 나눔.

```java
Map<Boolean, List<Integer>> evenOdd = numbers.stream()
    .collect(Collectors.partitioningBy(n -> n % 2 == 0));

```

- `true` → 짝수 리스트
- `false` → 홀수 리스트
- 항상 두 개의 키가 생성됨

**분할 + 집계**

```java
Map<Boolean, Long> passCount = students.stream()
    .collect(Collectors.partitioningBy(
        s -> s.getScore() >= 70,
        Collectors.counting()
    ));

```

## 10. 병렬 스트림

### 10-1. 동작 원리

- `parallelStream()` → 내부적으로 Fork/Join 프레임워크 사용
- 데이터를 분할해서 여러 스레드에서 동시에 처리 후 병합

```java
List<Integer> numbers = IntStream.rangeClosed(1, 1_000_000)
    .boxed().toList();

long sum1 = numbers.stream().mapToLong(Integer::longValue).sum();
long sum2 = numbers.parallelStream().mapToLong(Integer::longValue).sum();

```

### 10-2. 주의사항

1. **작은 데이터셋** → 오히려 느림 (스레드 관리 오버헤드)
2. **순서 보장 안 됨** → 필요하면 `forEachOrdered` 사용
3. **스레드 안전성** → 외부 변경 불가, `Collector` 사용 권장

   ```java
   // 위험
   List<Integer> list = new ArrayList<>();
   IntStream.range(0, 1000).parallel().forEach(list::add);

   // 안전
   List<Integer> safe = IntStream.range(0, 1000)
       .parallel().boxed().collect(Collectors.toList());

   ```

4. **Boxing/Unboxing 비용** → `IntStream`, `LongStream` 등 기본형 스트림 활용
5. **결합법칙 보장 필요** → reduce/collect 병합이 올바르게 동작해야 함
