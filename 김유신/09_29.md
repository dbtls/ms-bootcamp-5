# 09/29 회고록

## 5. 쓰레드 간 통신

### 5-1. 왜 필요한가?

- 멀티쓰레드 환경에서는 **공유 자원**을 다루기 때문에, 쓰레드 간 협력이 필요할 때가 많음.
- 예:

  - Producer-Consumer(생산자-소비자) 패턴
  - 데이터가 준비될 때까지 소비자가 기다려야 하는 상황
  - 여러 쓰레드가 순서대로 실행돼야 하는 상황

- 이때 단순 동기화(synchronized)만으로는 부족하고, 쓰레드 간 **신호(communication)**가 필요함.

### 5-2. wait(), notify(), notifyAll()

- `Object` 클래스에 정의된 메서드 (모든 객체에서 사용 가능).
- 반드시 `synchronized` 블록 안에서만 호출 가능.
- **wait()**
  - 현재 쓰레드가 모니터 락을 풀고 대기 상태로 들어감.
  - 다른 쓰레드의 `notify()` 또는 `notifyAll()` 호출이 있어야 깨어남.
- **notify()**
  - 대기(wait) 중인 쓰레드 중 하나를 깨움.
- **notifyAll()**
  - 대기 중인 모든 쓰레드를 깨움.

### 5-3. 예시: 생산자-소비자 패턴

```java
class SharedBuffer {
    private int data;
    private boolean empty = true;

    public synchronized void produce(int value) throws InterruptedException {
        while (!empty) {
            wait(); // 소비자가 가져갈 때까지 대기
        }
        data = value;
        empty = false;
        System.out.println("생산: " + value);
        notify(); // 소비자 깨움
    }

    public synchronized int consume() throws InterruptedException {
        while (empty) {
            wait(); // 생산자가 넣을 때까지 대기
        }
        empty = true;
        System.out.println("소비: " + data);
        notify(); // 생산자 깨움
        return data;
    }
}

public class ProducerConsumerExample {
    public static void main(String[] args) {
        SharedBuffer buffer = new SharedBuffer();

        Thread producer = new Thread(() -> {
            try {
                for (int i = 1; i <= 5; i++) buffer.produce(i);
            } catch (InterruptedException e) {}
        });

        Thread consumer = new Thread(() -> {
            try {
                for (int i = 1; i <= 5; i++) buffer.consume();
            } catch (InterruptedException e) {}
        });

        producer.start();
        consumer.start();
    }
}

```

**실행 흐름**

- 생산자가 데이터를 넣고 → notify()로 소비자 깨움
- 소비자가 데이터를 꺼내고 → notify()로 생산자 깨움
- 이렇게 교대로 실행됨

### 5-4. 주의할 점

- `wait()`/`notify()`는 반드시 **동기화 블록(synchronized)** 안에서 호출해야 함.
- `if` 대신 `while` 문을 써야 함 (스퍼리어스 웨이크업: 의도치 않게 깨는 경우 방지).
- 다수의 쓰레드가 대기하는 상황에서는 `notifyAll()`을 쓰는 것이 안전한 경우가 많음.

## 6. 데드락

### 6-1. 데드락이란?

- 둘 이상의 쓰레드가 서로 가진 리소스를 기다리며 무한 대기하는 상태
- 서로가 락을 점유한 채로 상대의 락을 기다리면서 프로그램이 멈춤

### 6-2. 데드락 발생 조건

- 상호 배제: 리소스는 한 번에 한 쓰레드만 사용
- 점유와 대기: 자원을 점유하면서 다른 자원 대기
- 비선점: 점유한 자원을 강제로 뺏을 수 없음
- 순환 대기: 리소스 대기가 원형 구조를 이룸

### 6-3. 데드락 예제

- method1: lock1 → lock2 순서로 획득
- method2: lock2 → lock1 순서로 획득
- 동시에 실행 시 서로 대기하며 무한 루프

```java
public class DeadlockExample {
    private final Object lock1 = new Object();
    private final Object lock2 = new Object();

    public void method1() {
        synchronized(lock1) {
            System.out.println(Thread.currentThread().getName() + ": lock1 획득");

            try { Thread.sleep(100); } catch (InterruptedException e) {}

            synchronized(lock2) {
                System.out.println(Thread.currentThread().getName() + ": lock2 획득");
            }
        }
    }

    public void method2() {
        synchronized(lock2) {
            System.out.println(Thread.currentThread().getName() + ": lock2 획득");

            try { Thread.sleep(100); } catch (InterruptedException e) {}

            synchronized(lock1) {
                System.out.println(Thread.currentThread().getName() + ": lock1 획득");
            }
        }
    }
}

```

### 6-4. 데드락 해결 방법

### 방법 1: 락 순서 통일

- 모든 쓰레드가 같은 순서로 락 획득
- 순환 대기를 없애 데드락 방지

```java
public class DeadlockSolution {
    private final Object lock1 = new Object();
    private final Object lock2 = new Object();

    public void method1() {
        synchronized(lock1) {
            synchronized(lock2) {
                // 작업 수행
            }
        }
    }

    public void method2() {
        synchronized(lock1) {
            synchronized(lock2) {
                // 작업 수행
            }
        }
    }
}

```

### 방법 2: 타임아웃 설정

- ReentrantLock의 tryLock 사용
- 일정 시간 내 락 획득 실패 시 포기 후 재시도

```java
public class TimeoutSolution {
    private final ReentrantLock lock1 = new ReentrantLock();
    private final ReentrantLock lock2 = new ReentrantLock();

    public void performTask() throws InterruptedException {
        while (true) {
            if (lock1.tryLock(1, TimeUnit.SECONDS)) {
                try {
                    if (lock2.tryLock(1, TimeUnit.SECONDS)) {
                        try {
                            // 작업 수행
                            break;
                        } finally {
                            lock2.unlock();
                        }
                    }
                } finally {
                    lock1.unlock();
                }
            }
            Thread.sleep(100); // 재시도 전 대기
        }
    }
}

```

## 7. java.util.concurrent 패키지

### 7-1. ExecutorService

- 스레드 풀 기반 작업 실행 관리 도구
- 직접 `new Thread()`로 쓰레드를 만드는 방식은 작업이 많아질수록 비효율적
  - 매번 쓰레드 생성·파괴 비용 발생
  - 쓰레드 개수 제한 관리 어려움
- ExecutorService는 **스레드 풀(Thread Pool)** 을 유지해 쓰레드를 재사용
- 주요 구현체
  - `newFixedThreadPool(n)`: 고정된 개수의 스레드 유지
  - `newCachedThreadPool()`: 필요할 때 쓰레드 생성, 일정 시간 안 쓰면 제거
  - `newSingleThreadExecutor()`: 단일 쓰레드로 순차 실행

```java
ExecutorService executor = Executors.newFixedThreadPool(3);

for (int i = 1; i <= 10; i++) {
    final int taskId = i;
    executor.submit(() -> {
        System.out.println("작업 " + taskId + " 실행 중 - " +
            Thread.currentThread().getName());
        try { Thread.sleep(1000); } catch (InterruptedException e) {}
    });
}
executor.shutdown();

```

- 스레드 관리 비용 절감, 동시 실행 제한으로 안정성 확보

### 7-2. Future와 Callable

- `Runnable`은 반환값이 없지만, `Callable`은 결과 반환 가능
- `Future`는 비동기 작업의 결과를 나중에 가져올 수 있는 핸들
- `future.get()` 호출 시 → 결과가 준비될 때까지 블로킹

```java
ExecutorService executor = Executors.newSingleThreadExecutor();

Callable<Integer> task = () -> {
    System.out.println("계산 시작...");
    Thread.sleep(2000);
    return 42;
};

Future<Integer> future = executor.submit(task);

System.out.println("다른 작업 수행...");
Integer result = future.get(); // 결과 대기
System.out.println("계산 결과: " + result);

executor.shutdown();

```

- 시간이 오래 걸리는 연산을 다른 쓰레드에 맡기고, 메인 쓰레드는 다른 일을 하다가 필요할 때 결과를 가져옴

### 7-3. CountDownLatch

- 여러 쓰레드의 작업이 모두 끝날 때까지 기다리게 할 수 있는 동기화 장치
- 생성 시 카운트를 정해두고, 각 쓰레드가 작업을 끝낼 때마다 `countDown()` 호출
- 대기 쓰레드는 `await()`에서 블로킹 → 카운트가 0이 되면 해제

```java
int workerCount = 3;
CountDownLatch latch = new CountDownLatch(workerCount);

for (int i = 1; i <= workerCount; i++) {
    final int workerId = i;
    new Thread(() -> {
        try {
            System.out.println("Worker " + workerId + " 작업 시작");
            Thread.sleep(workerId * 1000);
            System.out.println("Worker " + workerId + " 작업 완료");
        } catch (InterruptedException e) {}
        finally {
            latch.countDown();
        }
    }).start();
}

System.out.println("모든 작업자 대기 중...");
latch.await(); // 0 될 때까지 대기
System.out.println("모든 작업 완료!");

```

- 메인 쓰레드가 여러 하위 작업자들의 작업이 끝날 때까지 기다렸다가 후속 로직 실행

### 7-4. ConcurrentHashMap

- 멀티쓰레드 환경에서 안전한 Map
- 기존 `HashMap`은 동시에 put/get 시 충돌 발생 → `ConcurrentModificationException`
- `Hashtable`은 모든 메서드에 `synchronized` 적용 → 성능 저하
- `ConcurrentHashMap`은 **세분화된 락(분할 락)** 사용 → 동시성↑ 성능↑

```java
ConcurrentHashMap<String, Integer> map = new ConcurrentHashMap<>();

Thread[] threads = new Thread[10];
for (int i = 0; i < 10; i++) {
    final int threadId = i;
    threads[i] = new Thread(() -> {
        for (int j = 0; j < 100; j++) {
            map.merge("count", 1, Integer::sum);
            map.put("thread-" + threadId, j);
        }
    });
    threads[i].start();
}
for (Thread t : threads) t.join();

System.out.println("총 카운트: " + map.get("count"));

```

- 멀티코어 환경에서 락 경합 최소화, 높은 처리량 보장

### 7-5. BlockingQueue

- 생산자-소비자 패턴 구현에 최적화된 큐
- `put()`: 큐가 가득 차면 대기
- `take()`: 큐가 비면 대기
- 별도의 동기화 코드 없이 안전하게 사용 가능

```java
BlockingQueue<String> queue = new ArrayBlockingQueue<>(5);

Thread producer = new Thread(() -> {
    try {
        for (int i = 1; i <= 10; i++) {
            String item = "Item-" + i;
            queue.put(item); // 큐가 가득 차면 대기
            System.out.println("생산: " + item);
            Thread.sleep(500);
        }
    } catch (InterruptedException e) {}
});

Thread consumer = new Thread(() -> {
    try {
        for (int i = 0; i < 10; i++) {
            String item = queue.take(); // 큐가 비면 대기
            System.out.println("소비: " + item);
            Thread.sleep(1000);
        }
    } catch (InterruptedException e) {}
});

producer.start();
consumer.start();

```

- 동기화 처리 불필요, 생산자-소비자 로직을 단순화

## 8. 성능 최적화 팁

### 8-1. 스레드 풀 크기 설정

- 스레드 개수는 많다고 무조건 좋은 게 아님
- CPU 바운드 vs I/O 바운드 작업 성격에 따라 달라짐
  - **CPU 바운드 작업**: 계산 위주 (ex. 수학 연산, 이미지 처리) → CPU 코어 수만큼 스레드 사용하는 게 적절
  - **I/O 바운드 작업**: 네트워크·디스크 I/O 대기 많은 경우 → CPU가 쉬는 시간이 많으므로 더 많은 스레드 사용 가능

```java
public class ThreadPoolSizing {
    public static int getOptimalThreadCount() {
        int cpuCores = Runtime.getRuntime().availableProcessors();

        // CPU 집약적 작업
        int cpuBoundThreads = cpuCores;

        // I/O 집약적 작업 (90% 대기 가정)
        double blockingCoefficient = 0.9;
        int ioBoundThreads = (int)(cpuCores / (1 - blockingCoefficient));

        System.out.println("CPU 코어 수: " + cpuCores);
        System.out.println("CPU 집약적 작업 최적 스레드 수: " + cpuBoundThreads);
        System.out.println("I/O 집약적 작업 최적 스레드 수: " + ioBoundThreads);

        return ioBoundThreads;
    }
}

```

- 상황에 맞게 스레드 풀 크기를 조정하면 자원 낭비 최소화 가능

### 8-2. 락 경합 최소화

- 공유 자원 보호를 위해 락을 거는 것은 필수지만, 과도한 락은 성능 저하 원인
- **굵은 락 (coarse-grained lock)**: 긴 작업 전체에 락을 걸면 불필요하게 대기 시간 증가
- **세밀한 락 (fine-grained lock)**: 꼭 필요한 부분에만 락을 걸어 병렬성 보존

```java
public class LockOptimization {
    private final Object lock = new Object();

    // 굵은 락: 성능 저하 가능
    public void badMethod() {
        synchronized(lock) {
            doLongOperation();  // 사실은 동기화 불필요
            updateSharedData();
        }
    }

    // 세밀한 락: 동기화 최소화
    public void goodMethod() {
        doLongOperation(); // 락 필요 없음
        synchronized(lock) {
            updateSharedData(); // 공유 데이터 수정 시만 동기화
        }
    }

    private void doLongOperation() {}
    private void updateSharedData() {}
}

```

- 공유 데이터 수정 시점에만 락을 걸어 경합 줄이기

### 8-3. ThreadLocal 사용

- 각 스레드마다 독립적인 변수를 가질 수 있게 하는 도구
- 공유 객체를 피하고 스레드별로 상태를 분리해 동기화 비용을 없앰
- 예시: `SimpleDateFormat`은 스레드 안전하지 않음 → ThreadLocal로 스레드마다 독립 인스턴스 생성

```java
public class ThreadLocalExample {
    private static final ThreadLocal<SimpleDateFormat> dateFormatter =
        ThreadLocal.withInitial(() -> new SimpleDateFormat("yyyy-MM-dd"));

    public String formatDate(Date date) {
        return dateFormatter.get().format(date);
    }

    public static void main(String[] args) {
        ThreadLocalExample example = new ThreadLocalExample();

        for (int i = 0; i < 5; i++) {
            new Thread(() -> {
                Date now = new Date();
                String formatted = example.formatDate(now);
                System.out.println(Thread.currentThread().getName() + ": " + formatted);
            }).start();
        }
    }
}

```

- 동기화 불필요, 스레드마다 안전하게 독립된 객체 사용 가능
