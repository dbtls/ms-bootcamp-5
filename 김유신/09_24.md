# 09/24 회고록

## 1. 콜백 함수 기본 이해

### 1-1. 콜백 함수란?

- **정의**: 함수의 인자로 전달되어, 특정 시점(작업 완료 후 등)에 실행되는 함수.
- **핵심**: “작업이 끝나면 이 함수를 불러라”라는 일종의 약속.
- **예시**

  ```jsx
  function greeting(name, callback) {
    console.log("안녕 " + name);
    callback();
  }
  greeting("유신", () => {
    console.log("반가워!");
  });
  // 출력:
  // 안녕 유신
  // 반가워!
  ```

### 1-2. 동기 vs 비동기

- **동기(Synchronous)**: 코드가 위에서 아래로 차례대로 실행됨.
  ```jsx
  console.log("첫 번째");
  console.log("두 번째");
  // 결과: 첫 번째 → 두 번째
  ```
- **비동기(Asynchronous)**: 오래 걸리는 작업을 기다리지 않고, 끝나면 콜백으로 결과를 처리.
  ```jsx
  console.log("첫 번째");
  setTimeout(() => console.log("두 번째"), 1000);
  console.log("세 번째");
  // 결과: 첫 번째 → 세 번째 → (1초 뒤) 두 번째
  ```
  - 프로그램이 멈추지 않고 다른 일을 처리할 수 있음.
  - 콜백 :비동기 작업의 “완료 시점”을 다룸

### 1-3. 콜백

- 콜백을 연속적으로 사용하면 코드가 **피라미드 구조**처럼 깊게 중첩되어 가독성이 나빠짐.
- **예시** (1초마다 숫자 증가):

  ```jsx
  function increaseAndPrint(n, callback) {
    setTimeout(() => {
      const increased = n + 1;
      console.log(increased);
      if (callback) callback(increased);
    }, 1000);
  }

  increaseAndPrint(0, (n) => {
    increaseAndPrint(n, (n) => {
      increaseAndPrint(n, (n) => {
        increaseAndPrint(n, (n) => {
          increaseAndPrint(n, () => {
            console.log("끝!");
          });
        });
      });
    });
  });
  ```

- **실행 결과**

  ```
  1
  2
  3
  4
  5
  끝!

  ```

- **문제점**
  - 가독성 저하 (들여쓰기 심함)
  - 유지보수 어려움
- 대안
  - **Promise**: 콜백을 체이닝 구조로 단순화
  - **async/await**: 동기 코드처럼 읽히는 비동기 코드 작성 가능

## 2. 자바스크립트의 메모리 구조와 비동기 실행

### 자바스크립트 엔진의 기본 메모리 구조

- **콜 스택(Call Stack)**
  현재 실행 중인 함수들의 “작업 공간”.
- **힙(Heap)**
  객체, 배열, 함수 같은 참조형 데이터 저장.
- **큐(Queue)**
  - **Task Queue (Callback Queue)**: `setTimeout`, 이벤트 핸들러 등이 들어옴
  - **Microtask Queue**: `Promise.then`, `async/await` 재개 등이 들어옴
- **이벤트 루프(Event Loop)**
  스택이 비면 큐에서 콜백을 꺼내 실행.

### Web API와 이벤트 루프

- 브라우저/Node.js가 제공하는 비동기 기능(`setTimeout`, Ajax 등)은 **Web API 영역**에서 처리.
- 완료된 콜백은 **Callback Queue(Task Queue)**에 들어감.
- \*이벤트 루프(Event Loop)\*\*는 스택이 빌 때마다 Microtask Queue → Task Queue 순으로 콜백을 실행.

### 실행 흐름

- 예시

  ```jsx
  console.log("A");

  setTimeout(() => {
    console.log("B");
  }, 1000);

  console.log("C");
  ```

  #### (1) `"A"` 실행 직후

  ```
  [Call Stack]        [Web API]           [Callback Queue]
  ---------------------------------------------------------
  console.log("A")    (비어있음)          (비어있음)

  출력: A

  ```

  ***

  #### (2) `setTimeout` 실행

  ```
  [Call Stack]        [Web API]           [Callback Queue]
  ---------------------------------------------------------
  setTimeout          타이머(1초) 등록    (비어있음)

  - 콜백 함수(() => console.log("B"))는 Web API로 넘어감
  - 타이머 카운트 시작

  ```

  ***

  #### (3) `"C"` 실행

  ```
  [Call Stack]        [Web API]           [Callback Queue]
  ---------------------------------------------------------
  console.log("C")    타이머 동작 중      (비어있음)

  출력: C

  ```

  ***

  #### (4) 1초 뒤 타이머 만료

  ```
  [Call Stack]        [Web API]           [Callback Queue]
  ---------------------------------------------------------
  (비어있음)          (비어있음)          [() => console.log("B")]

  - Web API가 콜백을 Task Queue로 이동

  ```

  ***

  #### (5) 이벤트 루프 동작

  ```
  [Call Stack]        [Web API]           [Callback Queue]
  ---------------------------------------------------------
  () => console.log("B")   (비어있음)     (비어있음)

  - 이벤트 루프가 스택이 빈 걸 확인 후
  - Queue에 있던 콜백을 스택으로 올림

  ```

  출력: B

  ***

  #### 최종 출력 순서

  ```
  A
  C
  B

  ```

### 요약

- **콜 스택**: 즉시 실행되는 코드 저장
- **Web API**: 비동기 작업(타이머 등) 처리
- **Callback Queue**: 끝난 콜백 대기
- **이벤트 루프**: 스택이 비면 Queue에서 꺼내 실행

## 3. Promise

- 자바스크립트에서 **비동기 작업의 상태와 결과를 표현하는 내장 객체**.
- “아직 완료되지 않은 작업”을 나타내며, 완료되면 결과를 꺼낼 수 있게 해줌.
- 상태 3가지:

  - **pending (대기)**: 아직 처리 중
  - **fulfilled (이행)**: 성공적으로 끝나서 `resolve` 호출됨
  - **rejected (거부)**: 실패해서 `reject` 호출됨

- 예시

  ```jsx
  function delay(ms) {
    return new Promise((resolve) => {
      setTimeout(() => resolve(`${ms}ms 대기 완료`), ms);
    });
  }

  delay(1000)
    .then((result) => {
      console.log(result); // 1000ms 대기 완료
      return delay(2000);
    })
    .then((result) => {
      console.log(result); // 2000ms 대기 완료
    })
    .catch((error) => {
      console.error("에러:", error);
    });
  ```

  - `.then()`은 Promise를 반환하기 때문에 **연속 실행(체이닝)** 가능.
  - 이전 결과를 다음 단계로 전달하면서 깔끔하게 연결할 수 있음.

## 4. async / await

- `async/await`는 **Promise 기반의 문법**.
- `async`를 붙인 함수는 항상 **Promise를 반환**한다.
- 함수 내부에서 `await` 키워드를 사용하면:
  - 해당 Promise가 **이행(fulfilled)** 될 때까지 함수 실행을 **잠시 멈춤**
  - 결과값을 받아 다음 줄부터 실행
- 비동기 코드를 동기 코드처럼 읽히게 해줌.

- 예제

  ```jsx
  function delay(ms) {
    return new Promise((resolve) => setTimeout(() => resolve(ms), ms));
  }

  async function run() {
    console.log("시작"); // 즉시 실행
    const a = await delay(1000); // 1초 대기 후 a=1000
    console.log(a, "ms 완료"); // 출력
    const b = await delay(500); // 0.5초 대기 후 b=500
    console.log(b, "ms 완료");
    return "끝"; // Promise.resolve("끝") 반환
  }

  run().then(console.log);
  ```

  **실행 결과**

  ```
  시작
  1000 ms 완료
  500 ms 완료
  끝

  ```

## 5. 단축 평가 (Short-circuit Evaluation)

- `&&`, `||` 연산자는 결과가 확정되면 평가를 멈추고 값을 반환 → **단축 평가**라고 부름.
- **Falsy 값**: `false, 0, -0, 0n, "", null, undefined, NaN`
- 그 외의 모든 값은 truthy

### OR 연산자 (`||`)

- 규칙: 앞 값이 **truthy**면 앞 값을 반환, falsy면 뒤 값을 반환.
- **활용: 기본값 설정**

  ```jsx
  const user = "" || "손님";
  console.log(user); // "손님"
  ```

### AND 연산자 (`&&`)

- 규칙: 앞 값이 **falsy**면 앞 값을 반환, truthy면 뒤 값을 반환.
- **활용: 조건부 실행**

  ```jsx
  const isLogin = true;
  isLogin && console.log("로그인 성공!"); // 실행됨
  ```

### Null 병합 연산자 (`??`)

- `??`는 **null 또는 undefined일 때만** 뒤 값을 반환.
- `||`와 달리 `0`, `""`, `false`는 무시하지 않음.

  ```jsx
  console.log(null ?? "기본값"); // "기본값"
  console.log(0 ?? "기본값"); // 0
  console.log("" ?? "기본값"); // ""
  ```

### 옵셔널 체이닝 (`?.`)

- **정의**: 객체의 깊은 속성을 접근할 때, 중간에 `null`이나 `undefined`가 나오면 에러를 내지 않고 `undefined` 반환.
- 기존 방식 (단축 평가 활용):
  ```jsx
  const user = {};
  console.log(user && user.profile && user.profile.name); // undefined
  ```
- 옵셔널 체이닝 방식:
  ```jsx
  const user = {};
  console.log(user?.profile?.name); // undefined
  ```
- 장점: 코드가 훨씬 짧고 가독성 좋아짐.
- `?.`은 함수 호출, 배열 접근에도 사용 가능:
  ```jsx
  user?.sayHello?.(); // 함수가 없으면 그냥 undefined
  arr?.[0]; // 배열이 없으면 undefined
  ```
