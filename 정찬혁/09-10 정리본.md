# 09-10

![image.png](image/0910_DB테이블_구조.png)

```sql
-- 1
select * from emp
where deptno in (10, 20, 30);

-- 2
select * from emp
where deptno not in (10,20)

-- 3
select * from emp where comm is not null;

-- 4
select comm, ifnull(comm, 100)
from emp;

-- 5
/* coalesce는 ifnull과 다르게 여러 개 값을 순서대로 체크 가능 */
select ename, coalesce(comm, job, '몰라') 
from emp;

-- 6
select empno, ename, job, mgr, sal
from emp
order by 5 asc, ename; 

-- 7
select empno, ename, job, mgr, sal, deptno
from emp
order by deptno, sal desc;

-- 8
select empno, ename, mgr*18 as 연봉
from emp
order by 3 limit 5;

-- 9
SELECT * FROM employees 
WHERE first_name LIKE 'S%';  -- S로 시작하는 이름
-- WHERE first_name LIKE '%n';  -- n으로 끝나는 이름
-- WHERE first_name LIKE '%a%'; -- a를 포함하는 이름
-- WHERE first_name LIKE '_o%'; -- 두 번째 글자가 o인 이름
-- WHERE first_name LIKE '_____'; -- 정확히 5글자인 이름
-- WHERE first_name LIKE 'a____'; -- a로 시작하고 5글자인 이름
```

1. in 연산자, deptno의 10, 20, 30 값이 들어있는 속성들을 출력
2. not in 연산자 10, 20을 제외한 모든 속성들 출력
3. is not null, null을 제외하고 출력
4. comm 값이 null이면 100으로 대체, 아니면 원래 값 그대로 사용
5. coalesce는 ifnull과 다르게 여러 개 값을 순서대로 체크 가능 
    1. comm null이 아니면 그대로 사용, comm이 null이면 job이 null인지 확인 null이 아니면 그냥 사용 둘 다 null이면 '몰라' 반환
6. SELECT empno(1), ename(2), job(3), mgr(4), sal(5) 5번인 sal 컬럼을 정렬
7. deptno은 asc(오름차순), sal desc(내림차순)
8.  asc정렬이라 연봉이 낮은 5명을 보여준다.

### Group by

```sql
select deptno, job, avg(sal) as '평균 급여'
from emp
where deptno != 10
group by deptno, job
having '평균 급여' < 3000;
```

- 10번 부서를 제외한 모든 사원의 부서별, 직무별로 평균 급여를 알고 싶다.
- 단 평균 급여가 3000 이상인 결과는 제외해라.

---

![image.png](image/0910_ERD.png)

ERD ( 기본키(PK), 외래키(FK)에 대한 )

- `EMPLOYEES.department_id` → `DEPARTMENTS.department_id` 참조
- `DEPARTMENTS.location_id` → `LOCATIONS.location_id` 참조

다른 테이블의 값들을 참조하여 가져올 수 있음

FK로 연결된 속성 이름이 꼭 같을 필요는 없지만, 참조 대상 PK와 타입이 같아야 한다.

```sql
CREATE TABLE Customers (
    id INT PRIMARY KEY,  -- INT 타입
    name VARCHAR(50)
);

CREATE TABLE Orders (
    order_no INT PRIMARY KEY,
    buyer_id INT,   -- INT 타입
    FOREIGN KEY (buyer_id) REFERENCES Customers(id)
    -- REFERENCES 외래키(FK)를 선언할 때 사용되는 키워드
);
```

Orders.buyer_id가 Customers.id를 참조하지만, 이름이 다르다

→ 문법적으로 문제없음

즉, FK로 연결된 속성 이름이 꼭 같을 필요는 없지만, 참조 대상 PK와 타입이 같아야 한다.

### JOIN 종류

| **JOIN 종류** | **설명** |
| --- | --- |
| **Cross Join** | 모든 가능한 쌍이 나타남 (Cartesian Product) |
| **Inner Join** | 조인 조건을 만족하는 튜플만 나타남 |
| **Outer Join** | 조인 조건을 만족하지 않는 튜플도 null과 함께 나타남 |
| **Self Join** | 자기 자신과 조인 |

### 1. Cross Join

```sql
-- 방법 1
SELECT e.first_name, d.department_name
FROM employees e, departments d;

-- 방법 2
SELECT e.first_name, d.department_name
FROM employees e
CROSS JOIN departments d;

-- 결과 동일
```

- 조건 없이 FROM A, B  또는 CROSS JOIN만 쓰면 됨
- 결과 행 수 = (테이블A 행 수) x (테이블B 행 수)
- 실무에서 잘 쓰이지 않음

### 2. INNER JOIN

**2-1 Simple Join**

```sql
SELECT e.first_name, e.last_name, d.department_name
FROM employees e, departments d
WHERE e.department_id = d.department_id
```

- 전통적인 조인 방식
- JOIN 키워드 없이, WHERE 절에서 조인 조건을 지정

**2-2 ANSI JOIN 문법** 

**JOIN ~ ON**

```sql
-- JOIN ~ ON
SELECT e.first_name, e.last_name, d.department_name
from employees e
JOIN departments d ON e.department_id = d.department_id;
```

- ANSI JOIN 문법에서는 JOIN 뒤에 테이블 이름 + 별칭을 바로 써주는 것이 일반적

Simple Join VS ANSI JOIN(JOIN ~ON) 차이점

| 항목 | ANSI JOIN  | Simple JOIN |
| --- | --- | --- |
| 문법(사용법) | JOIN …ON … | FROM A, B WHERE~ |
| 조인 타입 | 명시적 | 내부 조인만 가능 |
| 가독성 | 좋음  | 다소 떨어짐 |
| 결과 | 조건 맞는 행만 선택 | 조건 맞는 행만 선택 |
| 외부조인 | 가능 | 어렵다 |
- Simple Join과 JOIN ~ ON의 결과는 같다.
- 그렇다고 Simple Join과 다른 ANSI JOIN의 결과값이 같은 건 아니다.
- 하지만 ANSI JOIN 방식이 최신 SQL 표준이라 실무에서는 이걸 권장한다.

**JOIN ~ USING (동일한 컬럼명일 때)**

```sql
-- JOIN ~ USING
SELECT e.first_name, e.last_name, d.department_name
FROM employees e
JOIN departments d USING(department_id);   -- <- 차이점
```

- USING(department_id) → 두 테이블에서 같은 이름의 컬럼을 기준으로 조인
- ON 절과 비슷하지만, 컬럼 이름을 한 번만 쓰면 됨

**NATURAL JOIN**

```sql
SELECT *
FROM employees
NATURAL JOIN departments;
```

- 두 테이블에 공통으로 존재하는 컬럼 이름을 기준으로 조인.
- employees와 departments 모두 department_id가 있으므로 가능
    - employees에 department_id가 있고 departments에 department_id가 없다면 불가능