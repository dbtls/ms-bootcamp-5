# 배열 메서드 - 고급

**forEach**

- 배열이 가지고 있는 내장 함수
- 각 요소에 함수를 적용하고, 반환값은 없다. (undefined 반환)
- 단순 반복용이다. (map/filter와 달리 체이닝 불가)

```jsx
const numbers = [1, 2, 3, 4, 5];

numbers.forEach(num => {
				console.log(num * 2); // 2, 4, 6, 8, 10
});

numbers.forEach(num => {
				console.log(num * num); // 1, 4, 9, 16, 25
```

**map**

- 각 요소를 변환한 뒤, 새 배열을 만들어 리턴
- 불변성을 유지한다. (원본의 배열을 건드리지 않는다.)

```jsx
const doubled = numbers.map(num => num * 2);
console.log(doubled); // [2, 4, 6, 8, 10]
```

**filter**

- 조건에 따라 참이 되는 것만 배열에 담아서 리턴 (필터링, 조건 선별)

```jsx
const evens = numbers.filter(num => num % 2 === 0);
console.log(evens); // [2, 4]
```

**reduce**

- 누적 함수: 누산기(acc)와 현재 값(cur)을 활용한다.
- 배열을 숫자, 문자열, 객체 등 원하는 형태로 축소 가능하다.

```jsx
const sum = numbers.reduce((acc, cur) => acc + cur, 0);
console.log(sum); // 15

// 평균 구하기
const avg = numbers.reduce((acc, cur, idx, arr) => {
				if (idx === arr.length - 1) {
					return (acc + cur) / arr.length;
				}
				return acc + cur;
}, 0);
console.log(avg); // 3
```

**find와 findIndex**

- find vs filter
    - find: 조건을 만족하는 첫 번째 요소를 반환한다. (객체 자체)
    - filter: 조건을 만족하는 모든 요소를 배열로 반환한다.

```jsx
const users = [
	{ id: 1, name: '김철수' },
	{ id: 2, name: '이영희' },
	{ id: 3, name: '박민수' }
];

const user = users.find(u => u.id === 2);
console.log(user); // { id: 2, name: '이영희' }

const index = users.findIndex(u => u.id === 2);
console.log(index); // 1
```

**splice와 slice**

```jsx
// splice - 원본 배열 수정
const numbers = [10, 20, 30, 40];
const index = numbers.indexOf(30);
numbers.splice(index, 1); // index부터 1개 제거
console.log(numbers); // [10, 20, 40] (원본 변경)

// slice 원본 배열 유지
const arr = [10, 20, 30, 40];
const sliced = arr.slice(0, 2); // 0부터 2 전까지
console.log(sliced); // [10, 20]
console.log(arr); // [10, 20, 30, 40] (원본 유지)
```

**shift, unshift, pop, push**

```jsx
const numbers = [10, 20, 30, 40];

// shift - 첫 번째 요소 제거 및 반환
const first = numbers.shift();
console.log(first); // 10
console.log(numbers); // [20, 30, 40]

// unshift - 앞에 추가
numbers.unshift(5);
console.log(numbers); // [5, 20, 30, 40]

// pop - 마지막 요소 제거 및 반환
const last = numbers.pop();
console.log(last); // 40
console.log(numbers); // [5, 20, 30]

// push - 뒤에 추가
numbers.push(50);
console.log(numbers); // [5, 20, 30, 50]
```

**concat과 join**

```jsx
// concat - 배열 합치기
const arr1 = [1, 2, 3];
const arr2 = [4, 5, 6];
const combined = arr1.concat(arr2);
console.log(combined); // [1, 2, 3, 4, 5, 6]

// join - 문자열로 합치기
const array = [1, 2, 3, 4, 5];
console.log(array.join());      // "1,2,3,4,5" - 자동으로 `,` 생성
console.log(array.join(' '));   // "1 2 3 4 5"
console.log(array.join(' - ')); // "1 - 2 - 3 - 4 - 5"
```

**indexOf와 includes**

```jsx
const fruits = ['사과', '바나나', '오렌지', '포도'];

// indexOf - 인덱스 찾기
console.log(fruits.indexOf('바나나')); // 1
console.log(fruits.indexOf('수박')); // -1 (없음)

// includes - 포함 여부 확인
console.log(fruits.includes('오렌지')); // true
console.log(fruits.includes('수박')); // false
```

# 반복문

## for문

```jsx
// 기본 for문
for (let i = 0; i < 5; i++) {
	console.log(i);
}

// 배열 순회
const colors = ['red', 'green', 'blue'];
for (let i = 0; i < colors.length; i++) {
	console.log(colors[i]);
}
```

## while문

```jsx
let count = 0;
while (count < 5) {
	console.log(count);
	count++;
}
```

## for … of 와 for … in

- for … of: 배열, 문자열, Set, Map 같은 Iterable 객체를 순회한다.
- for … in: 객체의 Key를 순회한다. (배열에는 잘 사용하지 않는다.)

```jsx
// for .. of (배열 요소 순회)
const fruits = ['사과', '바나나', '오렌지'];
for (let fruit of fruits) {
	console.log(fruit);
}
/*
사과
바나나
오렌지
*/

// for ... in (객체 속성 순회)
const person = { name: '김철수', age: 25 };
for (let key in person) {
	console.log(`${key}: ${person[key]}`);
}
/*
name: 김철수
age: 25
*/
```

## break와 continue

```jsx
// break - 반복문 종료
for (let i = 0; i < 10; i++) {
	if (i === 5) break;
	console.log(i); // 0, 1, 2, 3, 4
}

// continue - 다음 반복으로 건너뛰기
for (let i = 0; i < 5; i++) {
	if (i === 2) continue;
	console.log(i); // 0, 1, 3, 4
}
```

## 반복문 실습

```jsx
// 배열의 합 구하기
function sumOf(numbers) {
	let sum = 0;
	for (let i = 0; i < numbers.length; i++) {
		sum += numbers[i];
	}
	return sum;
}

const result = sumOf([1, 2, 3, 4, 5]);
console.log(result); // 15

// 내장 함수 사용
const arr = [1, 2, 3, 4, 5];
let sum = arr.reduce((acc, cur) => {
		return acc + cur;
}, 0);
console.log(sum);

// 3의 배수만 출력하기
for (let i = 1; i < 20; i ++) {
	if (i % 3 === 0) {
		console.log(i); // 3, 6, 9, 12, 15, 18
	}
}

// 내장 함수 사용
const array = [];
for (let i = 1; i < 20; i++) {
	array.push(i);
}
let result = array.filter((n) => n % 3 === 0);
console.log(result);
```

# 클래스와 프로토타입

- 생성자 함수와 클래스 문법은 본질적으로는 같은 원리이다. (프로토타입 기반 상속)

## 객체 생성자

```jsx
// 객체 생성자 함수
function Animal(type, name, sound) {
	this.type = type;
	this.name = name;
	this.sound = sound;
	this.say = function() {
		console.log(this.sound);
	};
}

// 인스턴스 생성
const dog = new Animal('개', '멍멍이', '멍멍');
const cat = new Animal('고양이', '야옹이', '야옹');

dog.say(); // 멍멍
cat.say(); // 야옹

cat.say = function() {
	console.log("Meow");
};

cat.say(); // Meow
```

## 프로토타입

```jsx
function Animal(type, name, sound) {
	this.type = type;
	this.name = name;
	this.sound = sound;
}

// 프로토타입에 메서드 추가
Animal.prototype.say = function() {
	console.log(this.sound);
};

// 프로토타입에 공유 값 추가
Animal.prototype.sharedValue = 1;

const dog = new Animal('개', '멍멍이', '멍멍');
const cat = new Animal('고양이', '야옹이', '야옹');

dog.say(); // 멍멍
cat.say(); // 야옹
console.log(dog.sharedValue); // 1
console.log(cat.sharedValue); // 1
```

## 프로토타입 상속

```jsx
function Animal(type, name, sound) {
	this.type = type;
	this.name = name;
	this.sound = sound;
}

Animal.prototype.say = function() {
	console.log(this.sound);
};

// Dog 생성자
function Dog(name, sound) {
	Animal.call(this, '개', name, sound);
}
Dog.prototype = Object.create(Animal.prototype);
Dog.prototype.constructor = Dog;

// Cat 생성자
function Cat(name, sound) {
	Animal.call(this, '고양이', name, sound);
}
Cat.prototype = Object.create(Animal.prototype);
Cat.prototype.constructor = Cat;

const dog = new Dog('멍멍이', '멍멍');
const cat = new Cat('야옹이', '야옹');

dog.say();  // 멍멍
cat.say();  // 야옹
```

## ES6 클래스

- ES6 클래스는 문법적 설탕(Syntactic Sugar) → 내부는 프로토타입

```jsx
// ES6 클래스 문법
class Animal {
	constructor(type, name, sound) {
		this.type = type;
		this.name = name;
		this.sound = sound;
	}
	
	// 메서드는 자동으로 프로토타입에 등록
	say() {
		console.log(this.sound);
	}
}

const dog = new Animal('개', '멍멍이', '멍멍');
const cat = new Animal('고양이', '야옹이', '야옹');

dog.say(); // 멍멍
cat.say(); // 야옹
```

## 클래스 상속

```jsx
class Animal {
	constructor(type, name, sound) {
		this.type = type;
		this.name = name;
		this.sound = sound;
	}
	
	say() {
		console.log(this.sound);
	}
}

// extends로 상속
class Dog extends Animal {
	constructor(name, sound) {
		super('개', name, sound); // 부모 생성자 호출
	}
}

class Cat extends Animal {
 constructor(name, sound) {
	 super('고양이', name, sound);
	}
}

const dog = new Dog('멍멍이', '멍멍');
const cat = new Cat('야옹이', '야옹');
const dog2 = new Dog('왈왈이', '왈왈');
const cat2 = new Cat('냐옹이', '냐옹');

dog.say(); // 멍멍
cat.say(); // 야옹
dog2.say(); // 왈왈
cat2.say(); // 냐옹
```

# 에러 처리와 비동기 프로그래밍

## try … catch 에러 처리

```jsx
// 기본 에러 처리
try {
	// 에러가 발생할 수 있는 코드
	const result = someFunction();
	console.log(result);
} catch (error) {
	// 에러 처리
	console.error('에러 발생:', error.message);
} finally {
	// 항상 실행되는 코드
	console.log('정리 작업');
}

// 에러 던지기
function divide(a ,b) {
	if (b === 0) {
		throw new Error('0으로 나눌 수 없습니다!');
	}
	return a / b;
}

try {
	const result = divide(10, 0);
} catch (error) {
	console.error(error.message);
}
```

## 동기 vs 비동기

<img width="1326" height="790" alt="Image" src="https://github.com/user-attachments/assets/65eaa02e-0569-49d3-a63b-4f673775afef" />

- **동기 처리**: 작업이 끝날 때까지 기다린다.
- **비동기 처리**: 작업을 시작하고 다른 작업을 진행한다.
- **콜백 지옥** 문제 → Promise로 개선 → async/await으로 가독성 극대화

## setTimeout과 콜백

```jsx
console.log('시작');

setTimeout(() => {
		console.log('2초 후 실행');
}, 2000);

console.log('끝');

/* 출력 순서
시작
끝
2초 후 실행
*/

function work(callback) {
	console.log("work start");
	
	setTimeout(() => {
			console.log("setTimeout() start");
			console.log("setTimeout() end");
			
			callback();
	}, 1000);
}

work(() => {
		console.log("work end");
});
/* 출력 순서
work start
setTimeout() start
setTimeout() end
work end
*/
```

## Promise

- pending(대기), fulfilled(성공), rejected(실패)

```jsx
// Promise 생성
function delay(ms) {
	return new Promise((resolve, reject) => {
			setTimeout(() => {
					resolve(`${ms}ms 대기 완료`);
			}, ms);
	});
}

// Promise 사용
delay(1000)
		.then(result => {
				console.log(result);
				return delay(2000);
		})
		.then(result => {
				console.log(result);
		})
		.catch(error => {
				console.error('에러:', error);
		});

/* 출력 결과
1000ms 대기 완료
2000ms 대기 완료
*/
```

## async/await

```jsx
// Promise 생성
function delay(ms) {
	return new Promise((resolve, reject) => {
			setTimeout(() => {
				resolve(`${ms}ms 대기 완료`);
			}, ms);
	});
}

// async 함수
async function fetchData() {
	try {
		console.log('데이터 요청 시작');
		
		// 1초 대기
		await delay(1000);
		console.log('첫 번째 작업 완료');
		
		// 2초 대기
		await delay(2000);
		console.log('두 번째 작업 완료');
		
		return '모든 작업 완료!';
	} catch (error) {
		console.error('에러 발생:', error);
	}
}

// 실행
fetchData().then(result => {
		console.log(result);
});

/* 출력 결과
데이터 요청 시작
첫 번째 작업 완료
두 번째 작업 완료
모든 작업 완료
*/
```

## Promise.all 과 Promise.race

- Promise.all: 모두 성공해야 성공, 하나라도 실패하면 전체 rejected
- Promise.race: 가장 먼저 완료된 하나만 반환

```jsx
async function getMultipleData() {
	// 병렬 처리
	const results = await Promise.all([
		delay(1000),
		delay(2000),
		delay(3000),
	]);
	
	console.log('모든 작업 완료:', results);
}

async function getFastestData() {
	// 가장 빠른 것 하나만
	const fastest = await Promise.race([
		delay(1000),
		delay(2000),
		delay(3000)
	]);
	
	console.log('가장 빠른 결과:', fastest);
}
```

# 단축평가

- AND(&&) - 둘 다 참일 때만 참. 첫 번째 조건이 거짓이라면 두 번째 조건을 실행하지 않는다.
- OR(??) - 둘 중 하나만 참이라도 참. 첫 번째 조건이 참이라면 두 번째 조건을 실행하지 않는다.
- ?? - OR 연산과 비슷하지만 참, 거짓을 판단하는 기준이 값으로만 판단한다.

```jsx
console.log(true && "hi"); // hi
console.log(false && "hi"); // false

console.log(true || "hi"); // true
console.log(false || "hi"); // hi

// 자바스크립트가 false라고 판단하는 값
console.log("" || "hi"); // hi
console.log(0 || "hi"); // hi
console.log(null || "hi"); // hi
console.log(undefined || "hi"); // hi

console.log("=====??=====");
console.log("" ?? "hi"); //
console.log(0 ?? "hi"); // 0
console.log(null ?? "hi"); // hi
console.log(undefined ?? "hi"); // hi

console.log(1 ?? "hi"); // 1
```
