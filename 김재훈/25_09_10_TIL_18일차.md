# SQL

## SQL이란?

- **SQL(Structured Query Language)**은 관계형 데이터베이스를 조작하기 위한 표준 언어이다.
- 특징
    - 대부분의 SQL 명령은 세미콜론(`;`)으로 끝난다.
    - 키워드는 대소문자를 구분하지 않지만, 가독성을 위해 대문자로 쓰는 것이 일반적이다.
    - 데이터는 대소문자를 구분한다.

```sql
SELECT 컬럼명(, 컬럼명) FROM 테이블명(, 테이블명)
```

## MySQL을 계산기로 사용하기

```sql
-- 수식 계산
SELECT 3 + 5;
SELECT 10 * 2.5;

-- 함수 사용
SELECT SIN(PI()/4), (4+1)*5;

-- 여러 문장 실행
SELECT NOW(); SELECT VERSION(); -- DBMS가 편하게 사용하라고 함수를 미리 제공한다.

-- 여러 줄에 걸쳐 작성하는 것도 문제가 없다. 문장과 문장은 ';'으로 구분한다.
SELECT
	USER(),
	CURRENT_DATE();
```

# 테이블과 데이터 구조

## 데이터베이스 용어

| **용어** | **설명** |
| --- | --- |
| Table | 데이터를 저장하는 2차원 구조 |
| Row (행) | 레코드, 튜플 - 하나의 데이터 항목 |
| Column (열) | 필드, 속성 - 데이터의 특정 속성 |
| Primary Key | 각 행을 고유하게 식별하는 키 |

## 샘플 테이블 생성

```sql
-- employees 테이블 생성
CREATE TABLE employees (
	employee_id INT(11) UNSIGNED NOT NULL,
	first_name VARCHAR(20),
	last_name VARCHAR(25) NOT NULL,
	email VARCHAR(25) NOT NULL,
	phone_number VARCHAR(20),
	hire_date DATE NOT NULL,
	job_id VARCHAR(10) NOT NULL,
	salary DECIMAL(8, 2) NOT NULL,
	commission_pct DECIMAL(2, 2),
	manager_id INT(11) UNSIGNED,
	department_id INT(11) UNSIGNED,
	PRIMARY KEY (employee_id)
);

-- 테이블 목록 확인
SHOW TABLES;

-- 테이블 구조 확인
DESC employees;
```

# SELECT

## SELECT 기본 문법

```sql
SELECT [DISTINCT] 컬럼명 [AS 별칭]
FROM 테이블명
WHERE 조건
GROUP BY 그룹 조건
HAVING 그룹 필터링 조건
ORDER BY 컬럼 [ASC|DESC];
```

- 실행 순서: FROM → WHERE → GROUP BY → HAVING → SELECT → ORDER BY

## 전체 데이터 조회

```sql
-- 모든 컬럼 조회
SELECT * FROM employees;

-- 특정 컬럼만 조회
SELECT first_name, last_name, salary
FROM employees;

-- 컬럼에 별칭 부여
SELECT
	first_name AS 이름,
	hire_date AS 입사일,
	salary AS 급여
FROM employees;
```

## 컬럼 결합과 연산

```sql
-- 문자열 결합
SELECT CONCAT(first_name, ' ', last_name) AS full_name
FROM employees;

-- 산술 연산
SELECT
	first_name,
	salary,
	salary * 12 AS annual_salary
FROM employees;
```

## 중복 제거

```sql
-- 중복된 값 제거
SELECT DISTINCT department_id
FROM employees;

-- 여러 컬럼의 조합으로 중복 제거
SELECT DISTINCT department_id, job_id
FROM employees;
```

# WHERE

## 비교 연산자

```sql
-- 같음
SELECT * FROM employees WHERE department_id = 90;

-- 크거나 같음
SELECT * FROM employees WHERE salary >= 10000;

-- 날짜 비교
SELECT * FROM employees WHERE hire_date > '2005-01-01'; # 2005년 1월 1일 이후 입사

-- 문자열 비교
SELECT * FROM employees WHERE last_name = 'King';
```

## 논리 연산자

```sql
-- AND 연산
SELECT * FROM employees
WHERE salary >= 10000 AND department_id = 90;

-- OR 연산
SELECT * FROM employees
WHERE department_id = 90 OR department_id = 100;

-- NOT 연산
SELECT * FROM employees
WHERE NOT department_id = 90;

-- 복합 조건
# 괄호에 따라 우선순위가 정해진다.
SELECT * FROM employees
WHERE (department_id = 90 OR department_id = 100) AND salary >= 10000;

# AND가 OR보다 우선순위가 높다.
SELECT * FROM employees
WHERE department_id = 90 OR department_id = 100 AND salary >= 10000;
```

## IN 연산자

```sql
# IN은 OR의 결합이다.

-- IN 사용
SELECT * FROM employees
WHERE department_id IN (90, 100, 110); // id가 90이거나, 100이거나, 110

-- NOT IN 사용
SELECT * FROM employees
WHERE department_id NOT IN (90, 100);
```

## BETWEEN 연산자

```sql
# BETWEEN은 작은 값이 앞에 위치해야 한다.

-- 범위 검색
SELECT * FROM employees
WHERE salary BETWEEN 5000 AND 10000;

-- 날짜 범위
SELECT * FROM employees
WHERE hire_date BETWEEN '2005-01-01' AND '2005-12-31';
```

# 패턴 매칭(LIKE)

## 와일드카드 문자

| **와일드카드** | **설명** |
| --- | --- |
| % | 0개 이상의 문자. ‘`*`’와 같은 의미 |
| _ | 정확히 1개의 문자 |

## LIKE 사용 예제

```sql
-- S로 시작하는 이름
SELECT * FROM employees
WHERE first_name LIKE 'S%';

-- n으로 끝나는 이름
SELECT * FROM employees
WHERE first_name LIKE '%n';

-- a를 포함하는 이름
SELECT * FROM employees
WHERE first_name LIKE '%a%';

-- 두 번째 글자가 o인 이름
SELECT * FROM employees
WHERE first_name LIKE '_o%';

-- 정확히 5글자인 이름
SELECT * FROM employees
WHERE first_name LIKE '_____';

-- a로 시작하고 5글자인 이름
SELECT * FROM employees
WHERE first_name LIKE 'a____';
```

# NULL 처리

## NULL 값 확인

```sql
-- NULL인 데이터 찾기
SELECT * FROM employees
WHERE commission_pct IS NULL;

-- NULL이 아닌 데이터 찾기
SELECT * FROM employees
WHERE commission_pct IS NOT NULL;
```

- NULL은 `=` 또는 `!=`연산자로 비교할 수 없다. 반드시 IS NULL 또는 IS NOT NULL을 사용해야 한다.

## NULL 처리 함수

```sql
-- IFNULL: NULL을 다른 값으로 대체
# 주어진 값이 NULL이라면 반환값을 반환한다.
SELECT
	first_name,
	IFNULL(commission_pct, 0) AS commission
FROM employees;

-- COALESCE: 여러 값 중 첫 번째 NOT NULL 값 반환
# 앞에서부터 NULL이 아닌 값을 반환하며, 모든 값이 NULL이라면 반환값(마지막 값)을 반환한다.
SELECT
	first_name,
	COALESCE(commission_pct, manager_id, 0) AS value
FROM employees;
```

# 정렬 (ORDER BY)

## 단일 컬럼 정렬

```sql
-- 오름차순 정렬 (기본값)
SELECT * FROM employees
ORDER BY salary;

-- 내림차순 정렬
SELECT * FROM employees
ORDER BY salary DESC;

-- 문자열 정렬
SELECT * FROM employees
ORDER BY last_name ASC; # 오름차순
```

## 다중 컬럼 정렬

```sql
-- 부서별로 정렬 후, 같은 부서 내에서 급여순 정렬
SELECT * FROM employees
ORDER BY department_id, salary DESC;

-- 별칭 사용
SELECT * FROM
	first_name,
	salary * 12 AS annual_salary
FROM employees
ORDER BY annual_salary DESC;

-- 숫자로도 정렬할 컬럼 지정 가능
SELECT empno, ename, job, sal, deptno
FROM emp ORDER BY 5, 2; # 5=deptno, 2=ename
```

# 결과 제한 (LIMIT)

## LIMIT 기본 사용법

```sql
-- 상위 5개 결과만 조회
SELECT * FROM employees
ORDER BY salary DESC
LIMIT 5;

-- 급여가 높은 상위 10명
SELECT first_name, last_name, salary
FROM employees
ORDER BY salary DESC
LIMIT 10;
```

## LIMIT과 OFFSET을 활용한 페이징

```sql
-- 기본 형태: LIMIT offset, count
-- 또는: LIMIT count OFFSET offset

-- 1페이지 (1~10번째 데이터)
SELECT * FROM employees
ORDER BY employee_id
LIMIT 0, 10;

-- 2페이지 (11~20번째 데이터)
SELECT * FROM employees
ORDER BY employee_id
LIMIT 10, 10;

-- 3페이지 (21~30번째 데이터)
SELECT * FROM employees
ORDER BY employee_id
LIMIT 20, 10;
```

## 페이징 공식과 실무 예제

```sql
-- 페이징 공식: LIMIT (페이지번호 - 1) * 페이지크기, 페이지크기

-- 페이지 크기가 10인 경우
-- 1페이지: LIMIT 0, 10
-- 2페이지: LIMIT, 10, 10
-- 3페이지: LIMIT, 20, 10

-- 게시판 페이징 예제 (최신글 순)
SELECT
	board_id,
	title,
	author,
	created_date
FROM board
ORDER BY created_date DESC
LIMIT 0, 10; -- 첫 페이지

-- 검색과 함께 페이징
SELECT
	board_id,
	title,
	author,
	created_date
FROM board
WHERE title LIKE '%MySQL%'
ORDER BY created_date DESC
LIMIT 10, 10; -- 2페이지
```

- **페이징 성능 최적화**
    - OFFSET이 큰 경우 성능 저하 발생
    - WHERE 조건과 인덱스를 활용한 커서 기반 페이징 고려
        
        ```sql
        -- 커서 기반 페이징 (더 효율적)
        SELECT * FROM employees
        WHERE employee_id > 1000
        ORDER BY employee_id
        LIMIT 10;
        ```
        

# SQL 함수

## 문자열 함수

```sql
-- 대소문자 변환
SELECT UPPER('hello'), LOWER('HELLO');

-- 문자열 결합
SELECT CONCAT('Hello', ' ', 'World');

-- 부분 문자열
SELECT SUBSTRING('Hello World', 1, 5);

-- 문자열 길이
SELECT LENGTH('Hello World');

-- 공백 제거
SELECT TRIM('  Hello  '), LTRIM('  Hello'), RTRIM('Hello  ');

-- 문자열 치환
SELECT REPLACE('Hello World', 'World', 'MySQL');

-- 패딩
SELECT LPAD('Hi', 5, '*'), RPAD('Hi', 5, '?');
```

## 숫자 함수

```sql
-- 반올림, 올림, 내림
SELECT ROUND(3.7), CEIL(3.2), FLOOR(3.9);

-- 절대값
SELECT ABS(-10);

-- 나머지
SELECT MOD(10, 3);

-- 제곱, 제곱근
SELECT POWER(2, 3), SQRT(16);

-- 최대값, 최소값
SELECT GREATEST(1, 2, 3), LEAST(1, 2, 3);
```

## 날짜 함수

```sql
-- 현재 날짜와 시간
SELECT CURDATE(), CURTIME(), NOW();

-- 날짜 포맷팅
SELECT DATE_FORMAT(NOW(), '%Y년 %m월 %d일');

-- 날짜 연산
SELECT
	DATE_ADD(NOW(), INTERVAL 1 DAY),
	DATE_SUB(NOW(), INTERVAL 1 MONTH);

-- 날짜 차이
SELECT DATEDIFF('2024-12-31', NOW());

-- 날짜 부분 추출
SELECT
	YEAR(NOW()),
	MONTH(NOW()),
	DAY(NOW()),
	DAYOFWEEK(NOW());
```

# 그룹 함수

## 집계 함수

```sql
-- COUNT: 행 개수
# NULL 제외하지만, COUNT(*)의 경우 NULL 여부와 관계없이 전체 행을 카운트한다.
# 그룹함수와 일반 컬럼은 공존할 수 없다. (예외적으로 그룹핑 조건에 들어간 컬럼이라면 공존이 가능하다.)
SELECT COUNT(*) FROM employees;
SELECT COUNT(commission_pct) FROM employees;

-- SUM: 합계
SELECT SUM(salary) FROM employees;

-- AVG: 평균
SELECT AVG(salary) FROM employees;

-- MAX, MIN: 최대값, 최소값
SELECT MAX(salary), MIN(salary) FROM employees;

-- 여러 집계 함수 함께 사용
SELECT
	COUNT(*) AS 직원수,
	AVG(salary) AS 평균급여,
	MAX(salary) AS 최고급여,
	MIN(salary) AS 최저급여
FROM employees;
```

## GROUP BY

```sql
-- 부서별 평균 급여
SELECT
	department_id,
	AVG(salary) AS avg_salary
FROM employees
GROUP BY department_id; # 그룹핑에 참여한 컬럼은 컬럼절에 나올 수 있다.

-- 여러 컬럼으로 그룹화
SELECT
	department_id,
	job_id,
	COUNT(*) AS count,
	AVG(salary) AS avg_salary
FROM employees
GROUP BY department_id, job_id;

-- 그룹별 정렬
SELECT
	department_id,
	COUNT(*) AS emp_count
FROM employees
GROUP BY department_id
ORDER BY emp_count DESC;
```

## HAVING

```sql
-- 그룹 조건 (평균 급여가 10000 이상인 부서)
SELECT
	department_id,
	AVG(salary) AS avg_salary
FROM employees
GROUP BY department_id
HAVING AVG(salary) >= 10000;

-- WHERE와 HAVING 함께 사용
SELECT
	department_id,
	AVG(salary) AS avg_salary
FROM employees
WHERE hire_date >= '2005-01-01'
GROUP BY department_id
HAVING COUNT(*) >= 5;
```

- WHERE vs HAVING
    - WHERE : 전체에 대한 조건
    - HAVING: 그룹핑된 결과에 대한 조건

# 테이블 관계와 JOIN 개념

## JOIN이란?

- 하나 이상의 테이블로부터 연관된 데이터를 검색해 오는 방법이다.

<img width="651" height="464" alt="Image" src="https://github.com/user-attachments/assets/fd941044-a8d7-45c2-9a4f-b876f7088481" />

## JOIN 종류

| **JOIN 종류** | **설명** |
| --- | --- |
| Cross Join | 모든 가능한 쌍이 나타난다. (Cartesian Product) |
| Inner Join | 조인 조건을 만족하는 튜플만 나타난다. |
| Outer Join | 조인 조건을 만족하지 않는 튜플도 null과 함께 나타난다. |
| Self Join | 자기 자신과 조인한다. |

# Cartesian Join (Cross Join)

## Cartesian Product

- 조인 조건이 없거나 잘못 기술된 경우 발생한다.
    
    ```sql
    -- 잘못된 조인 (조건 없음)
    SELECT * FROM employees, departments;
    -- 107명 * 27개 부서 = 2,889개 행
    ```
    
- 주의점
    - 의도하지 않은 대량의 데이터가 생성된다.
    - 반드시 WHERE 절에 조인 조건이 필요하다.
    - 실수로 조건을 누락하면 Cartesian Product가 발생한다.
    - 조인 조건은 최소 (조인 테이블 수 - 1)개 필요하다.

# Inner Join (EQUIJOIN)

## Simple Join

```sql
-- 전통적인 조인 방식
SELECT
	e.first_name,
	e.last_name,
	d.department_name
FROM
	employees e,
	departments d
WHERE
	e.department_id = d.department_id;
```

## ANSI JOIN 문법

```sql
-- JOIN ~ ON
SELECT
	e.first_name,
	e.last_name,
	d.department_name
FROM employees e
JOIN departments d ON e.department_id = d.department_id;

-- JOIN ~ USING (동일한 컬럼명일 때)
SELECT
	e.first_name,
	e.last_name,
	d.department_name
FROM employees e
JOIN departments d USING(department_id);

-- NATURAL JOIN (자동으로 같은 이름 컬럼 조인)
# 명시적이지 않아 예측하기 어렵고 유지보수성이 떨어진다.
SELECT * FROM employees NATURAL JOIN departments;
```
