# 객체지향 프로그래밍 핵심 개념

## OOP 핵심 개념

1. **추상화 (Abstraction)**
    - 복잡한 시스템이나 객체를 단순화하여 핵심적인 속성이나 기능만 나타내는 것이다.
    - 구체적인 세부 구현은 감추고, 필요한 인터페이스나 기능만 노출한다.
    - 예로, `Payment`라는 인터페이스를 정의하고, `CreditCardPayment`, `PayPalPayment` 등이 이를 구현하게 되면, 결제 방법의 구체적인 차이를 숨기고 동일한 결제 행위로 추상화 할 수 있다.
2. **캡슐화 (Encapsulation)**
    - 객체의 속성과 메서드를 하나의 논리적 단위로 묶고, 외부에서는 이 객체가 제공하는 메서드를 통해서만 접근하도록 제한하는 것이다.
    - 내부 구현 세부사항을 숨기고(정보 은닉), 외부에는 필요한 인터페이스만 노출한다.
    - 예로, `User` 클래스의 `password` 필드는 `private`으로 선언하고, 암호화 로직을 `setPassword()` 메서드 안에 두면 보안 및 유지보수 측면에서 유리하다.
3. **상속 (Inheritance)**
    - 상위(부모) 클래스의 속성과 메서드를 하위(자식) 클래스가 물려받아 사용하는 것이다.
    - 하위 클래스는 필요한 부분만 추가하거나 재정의(오버라이딩)해 기능을 확장할 수 있다.
    - 예로, `Animal` 클래스를 상속받은 `Dog`, `Cat` 클래스는 공통된 특성(`name`, `age`)를 물려받고, 각자의 독특한 행동(`bark()`, `meow()`)만 추가로 정의한다.
4. **다형성 (Polymorphism)**
    - 같은 메서드 호출이더라도, 객체의 실제 타입에 따라 다른 동작을 수행하는 특성이다.

## 설계 원칙이 중요한 이유

- **코드 유지보수성**을 높이기 위해서이다.
    - 설계 원칙을 지키면 각 객체가 가진 책임이 분명해지고, 수정 범위가 최소화된다.
- **확장성과 유연성**을 확보하기 위해서이다.
    - 설계 단계에서 변화 가능한 지점을 고려하고 적절히 추상화하면, 새로운 기능이 추가될 때 기존 코드를 크게 수정하지 않고도 확장할 수 있다.
- **팀 협업과 커뮤니케이션**을 원활하게 만들기 위해서이다.
    - 설계 원칙을 지키면 클래스나 메서드의 역할이 명확해져, 다른 팀원이 코드를 파악하기 수월해진다.
- **의존성과 결합도를 줄여 재사용성**을 높이기 위해서이다.
    - 설계 원칙에 따라 모듈 간 결합도를 낮추고 응집도를 높이면, 특정 모듈을 다른 프로젝트나 환경에서 재사용하기도 쉬워진다.

# SOLID 원칙

## SOLID란?

- 로버트 C.마틴(Robert C.Martin)이 제시한 객체지향 설계의 5가지 원칙의 첫 글자를 딴 약어이다.
- **S**RP (Single Responsibility Principle) - 단일 책임 원칙
- **O**CP (Open-Closed Principle) - 개방-폐쇄 원칙
- **L**SP (Liskov Substitution Principle) - 리스코프 치환 원칙
- **I**SP (Interface Segregation Principle) - 인터페이스 분리 원칙
- **D**IP (Dependency Inversion Principle) - 의존성 역전 원칙

## SRP - 단일 책임 원칙

- Single Responsibility Principle
- 클래스는 단 하나의 책임만 가져야 한다. (클래스를 변경하는 이유는 단 하나여야 한다.)
- 하나의 책임은 상황에 따라 클 수도 있고, 작을 수도 있으며, 문맥과 상황에 따라 다를 수 있어 모호하다.
- 중요한 기준은 변경이 있을 때 파급 효과가 적으면 단일 책임 원칙을 잘 따른 것이다.
    - 예) UI 변경, 객체의 생성과 사용 분리
- **예제**
    - 하나의 클래스는 하나의 책임만 가져야 한다.
    - `User` 클래스를 사용자의 정보 관리에만 집중시키고, 비밀번호 검증 로직은 `PasswordValidator` 클래스로 분리한다.
    
    ```java
    // SRP 예제
    class User {
        private String username;
        private String password;
    
        public User(String username) {
            this.username = username;
        }
    
        public void setPassword(String password) {
            // SRP 적용: 검증 로직은 별도 클래스로 분리
            if (PasswordValidator.isValid(password)) {
                this.password = password;
            } else {
                throw new IllegalArgumentException("Invalid password");
            }
        }
    
        public String getUsername() {
            return username;
        }
    }
    
    class PasswordValidator {
        public static boolean isValid(String password) {
            return password != null && password.length() >= 6;
        }
    }
    
    public class SRPDemo {
        public static void main(String[] args) {
            User user = new User("Alice");
            user.setPassword("abcdef"); // 유효한 패스워드
            System.out.println(user.getUsername());
        }
    }
    ```
    
- **핵심 포인트**
    - **User 클래스**
        - 말 그대로 **“사용자”**라는 개념(데이터)만 다룬다.
        - `username`과 `password` 두 개의 필드를 가지며, 사용자명과 비밀번호를 설정하고 가져오는 역할을 한다.
        - 비밀번호를 설정(setPassword)할 때, 검증 로직을 별도의 `PasswordValidator` 클래스를 호출해 유효성 체크를 한다.
    - **PasswordValidator 클래스**
        - **“비밀번호 유효성 검사”**만을 담당한다.
        - `isValid`라는 정적 메서드를 두어, 비밀번호가 `null`인지 아닌지, 특정 길이 이상인지 등을 판단한다.
    - **SRP의 장점**
        - **유지보수성**: `User` 클래스는 “사용자 데이터” 변경 사항에만 민감해진다.
        - **테스트 용이성**: `PasswordValidator` 테스트 시, `User`와 무관하게 단독 테스트가 가능하다.
        - **확장성**: 비밀번호 검증 규칙이 복잡해지거나 다른 형태로 확장되어도, `PasswordValidator` 안에서만 구현하면 되고, `User` 클래스는 건드릴 필요가 없다.

## OCP - 개방-폐쇄 원칙

- Open-Closed Principle
- 소프트웨어 요소는 확장에는 열려 있고, 수정에는 닫혀 있어야 한다. (새로운 기능을 추가할 때 기존 코드를 수정하지 않고 확장할 수 있어야 한다.)
- 확장에는 열려 있다는 것은 새로운 기능이나 요구사항이 들어올 때 기존 코드를 크게 수정하지 않고도 기능을 추가할 수 있어야 함을 의미한다.
- 수정에는 닫혀 있다는 것은 이미 잘 동작하는 로직을 안전하게 보호하여, 예상치 못한 버그나 오작동을 방지하자는 것을 의미한다.
- 인터페이스를 구현한 새로운 클래스를 하나 만들어서 새로운 기능을 구현하는 등 다형성을 활용하자.
- **예제**
    - 코드 수정 없이 새로운 기능을 확장할 수 있어야 한다.
    - 결제 방식을 추가해도 기존 코드를 수정하지 않도록 `PaymentMethod` 인터페이스를 활용한다.
    
    ```java
    // OCP 예제
    interface PaymentMethod {
        void pay(int amount);
    }
    
    class CreditCard implements PaymentMethod {
        @Override
        public void pay(int amount) {
            System.out.println("Processing credit card payment: $" + amount);
            // 신용카드 결제 로직
        }
    }
    
    class PayPal implements PaymentMethod {
        @Override
        public void pay(int amount) {
            System.out.println("Processing PayPal payment: $" + amount);
            // PayPal 결제 로직
        }
    }
    
    // 새로운 결제 방식 추가 시에도 아래 클래스는 수정 불필요
    class PaymentProcessor {
        public void process(PaymentMethod paymentMethod, int amount) {
            paymentMethod.pay(amount);
        }
    }
    
    class OCPDemo {
        public static void main(String[] args) {
            PaymentProcessor processor = new PaymentProcessor();
            processor.process(new CreditCard(), 100);
            processor.process(new PayPal(), 200);
    
            // 새로운 결제 방식(예: KakaoPay)을 추가해도
            // PaymentProcessor 코드는 수정 불필요
        }
    }
    ```
    
- **적용 포인트**
    - 새 클래스(`KakaoPay` 등)를 추가하더라도 `PaymentMethod`만 구현하면 된다.
    - `PaymentProcessor`를 수정 없이 확장이 가능하다.
    - 기존 코드를 안정적으로 유지하면서, 새 기능(결제 방식)을 쉽게 추가할 수 있다.
    - 이것이 바로 확장에는 열려 있고(Open), 기존 코드를 수정할 필요는 닫혀 있다(Closed)는 OCP의 핵심이다.

## LSP - 리스코프 치환 원칙

- Liskov Substitution Principle
- 자식 클래스는 부모 클래스를 대체할 수 있어야 한다. (자식 클래스는 부모 클래스가 기대하는 행위를 깨뜨리지 않고 대체 가능해야 한다.)
- 프로그램의 객체는 프로그램의 정확성을 깨뜨리지 않으면서 하위 타입의 인스턴스로 바꿀 수 있어야 한다.
- 다형성에서 하위 클래스는 인터페이스 규약을 다 지켜야 한다는 것으로 다형성을 지원하기 위한 원칙이다.
- 인터페이스를 구현한 구현체는 믿고 사용하려면 이 원칙이 필요하다.
- **LSP 위반 예제**
    - 자식 클래스는 부모 클래스를 대체해도 정상적으로 작동해야 한다.
    
    ```java
    // LSP 위반 예제
    class Rectangle {
        protected int width;
        protected int height;
    
        public Rectangle(int width, int height) {
            this.width = width;
            this.height = height;
        }
    
        public void setWidth(int width) {
            this.width = width;
        }
    
        public void setHeight(int height) {
            this.height = height;
        }
    
        public int area() {
            return width * height;
        }
    }
    
    class Square extends Rectangle {
        public Square(int side) {
            super(side, side);
        }
    
        @Override
        public void setWidth(int width) {
            super.width = width;
            super.height = width;  // 너비를 설정하면 높이도 같이 변경
        }
    
        @Override
        public void setHeight(int height) {
            super.height = height;
            super.width = height;  // 높이를 설정하면 너비도 같이 변경
        }
    }
    
    class LSPDemo {
        public static void main(String[] args) {
            Rectangle rect = new Square(5);
            rect.setWidth(10);
            System.out.println(rect.area()); // 100 (예상: 50)
        }
    }
    ```
    
- **LSP 위배의 문제점**
    - `Rectangle` 객체를 사용할 때는 `setWidth`와 `setHeight`가 독립적으로 작동한다고 가정한다.
    - 하지만 `Square` 클래스는 `setWidth`와 `setHeight` 메서드를 오버라이딩하여 두 값을 동시에 변경하도록 구현했다.
    - 이는 `Rectangle`을 사용하는 코드를 `Square`로 대체했을 때, **기존의 동작 계약(contract)을 위반**하게 된다.
- **LSP 준수 코드**
    
    ```java
    // 공통 인터페이스로 추상화
    interface Shape {
        int area();
    }
    
    class Rectangle implements Shape {
        private int width;
        private int height;
    
        public Rectangle(int width, int height) {
            this.width = width;
            this.height = height;
        }
    
        public void setWidth(int width) {
            this.width = width;
        }
    
        public void setHeight(int height) {
            this.height = height;
        }
    
        @Override
        public int area() {
            return width * height;
        }
    }
    
    class Square implements Shape {
        private int side;
    
        public Square(int side) {
            this.side = side;
        }
    
        public void setSide(int side) {
            this.side = side;
        }
    
        @Override
        public int area() {
            return side * side;
        }
    }
    
    class LSPDemo {
        public static void main(String[] args) {
            Shape rect = new Rectangle(5, 10);
            System.out.println("Rectangle area: " + rect.area()); // 50
    
            Shape square = new Square(5);
            System.out.println("Square area: " + square.area()); // 25
        }
    }
    ```
    
- **LSP 준수의 중요성**
    - 부모 클래스를 사용하는 모든 코드가 자식 클래스에서도 동일하게 동작해야 한다.
    - 이를 통해 다형성의 장점을 살리고, 코드 변경 시 오류를 최소화할 수 있다.
    - 상속은 “is-a 관계”에서만 사용해야 하며, 동작 규약을 준수해야 한다.

## ISP - 인터페이스 분리 원칙

- Interface Segregation Principle
- 클라이언트는 자신이 사용하지 않는 메서드에 의존하지 않아야 한다.
- 특정 클라이언트를 위한 인터페이스 여러 개가 범용 인터페이스 하나보다 낫다.
- 필요한 인터페이스를 작게 분리해, 불필요한 의존을 줄이는 것이 목적이다.
- 인터페이스가 명확해지고, 대체 가능성이 높아진다.
- **예제**
    - 인터페이스는 클라이언트가 필요로 하는 기능만 제공해야 한다.
    - 불필요한 메서드에 의존하지 않도록 인터페이스를 나눈다.
    
    ```java
    // ISP 예제
    interface OrderOperations {
        void placeOrder(String item);
    }
    
    interface CancelOperations {
        void cancelOrder(String orderId);
    }
    
    class OnlineOrderService implements OrderOperations, CancelOperations {
        @Override
        public void placeOrder(String item) {
            System.out.println("Order placed: " + item);
        }
    
        @Override
        public void cancelOrder(String orderId) {
            System.out.println("Order cancelled: " + orderId);
        }
    }
    
    // 주문 생성만 필요한 클라이언트
    class OrderClient {
        private final OrderOperations orderOps;
    
        public OrderClient(OrderOperations orderOps) {
            this.orderOps = orderOps;
        }
    
        public void createNewOrder() {
            orderOps.placeOrder("Book");
        }
    }
    
    // 주문 취소만 필요한 클라이언트
    class CancelClient {
        private final CancelOperations cancelOps;
    
        public CancelClient(CancelOperations cancelOps) {
            this.cancelOps = cancelOps;
        }
    
        public void cancelOrder(String orderId) {
            cancelOps.cancelOrder(orderId);
        }
    }
    
    class ISPDemo {
        public static void main(String[] args) {
            OnlineOrderService service = new OnlineOrderService();
            OrderClient client = new OrderClient(service);
    
            client.createNewOrder();
            service.cancelOrder("ORD1234");
        }
    }
    ```
    
- ISP 준수의 장점
    - **클라이언트의 독립성**
        - `OrderClient`는 자신이 필요한 `OrderOperations`에만 의존하며, 취소 기능과는 독립적이다.
    - **변경에 강함**
        - 인터페이스가 작고 특정 기능에 집중되어 있어, 변경 사항이 다른 클라이언트에 영향을 미치지 않는다.
    - **단일 책임 원칙(SRP)과의 연결성**
        - ISP는 단일 책임 원칙(SRP)과 밀접하게 연결되어 있다. 인터페이스가 작고 명확할수록 책임이 분리되고, 유지보수가 쉬워진다.

## DIP - 의존성 역전 원칙

- Dependency Inversion Principle
- 상위 모듈은 하위 모듈의 구현체가 아니라, 추상화에 의존해야 한다.
- 추상화는 세부사항에 의존하지 않아야 한다. 세부사항이 추상화에 의존해야 한다.
- 쉽게 이야기 해서 구현 클래스에 의존하지 말고, 인터페이스에 의존하라는 의미이다.
- 역할(Role)에 의존하게 해야 한다는 것과 같다. 객체 세상도 클라이언트가 인터페이스에 의존해야 유연하게 구현체를 변경할 수 있다.
- **예제**
    - 상위 모듈은 하위 모듈의 구현체가 아니라 추상화에 의존해야 한다.
    - 인터페이스에 의존해, 실제 구현체 교체가 가능하게 한다.
    
    ```java
    // DIP 예제
    interface MessageService {
        void sendMessage(String msg);
    }
    
    class EmailService implements MessageService {
        @Override
        public void sendMessage(String msg) {
            System.out.println("Email: " + msg);
        }
    }
    
    class SmsService implements MessageService {
        @Override
        public void sendMessage(String msg) {
            System.out.println("SMS: " + msg);
        }
    }
    
    class MessageSender {
        private final MessageService messageService;
    
        public MessageSender(MessageService messageService) {
            this.messageService = messageService;
        }
    
        public void send(String msg) {
            messageService.sendMessage(msg);
        }
    }
    
    class DIPDemo {
        public static void main(String[] args) {
            MessageSender emailSender = new MessageSender(new EmailService());
            emailSender.send("Hello via Email!");
    
            MessageSender smsSender = new MessageSender(new SmsService());
            smsSender.send("Hello via SMS!");
        }
    }
    ```
    
- **DIP 핵심**
    - **MessageService (추상화)**
        - 메시지 전송이라는 동작을 인터페이스로 정의한다.
        - 이 인터페이스만 보고도, 메시지를 전송할 수 있다는 것을 알 수 있다.
        - 구체적으로 이메일이든 SMS이든 전송 방법은 여기서는 알 필요가 없다.
    - **구체 구현체: EmailService, SmsService**
        - `EmailService`: 이메일 방식으로 메시지를 전송하는 실제 로직
        - `SmsService`: SMS 방식으로 메시지를 전송하는 실제 로직
        - 둘 다 `MessageService`를 구현하므로, 동일한 메서드(`sendMessage`)를 사용한다.
    - **MessageSender (상위 모듈)**
        - 주목 포인트: `MessageSender`는 `MessageService` 인터페이스에만 의존한다.
        - 실제로 이메일인지, SMS인지는 전혀 몰라도 된다.
        - 메시지 전송 시 `messageService.sendMessage(msg)`만 호출한다.
- **DIP 적용 포인트**
    - 상위 레벨인 `MessageSender`가 하위 레벨인 `EmailService`나 `SmsService`의 구현에 의존하지 않는다.
    - 구현체 교차 가능: 이메일 → SMS → 카카오톡 등 자유롭게 교체가 가능하다.
    - 유연하고 확장 가능: 다양한 메시지 전송 방법을 추가하거나 변경할 때 상위 모듈(MessageSender)은 건드리지 않아도 된다.
