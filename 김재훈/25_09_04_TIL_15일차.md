# 문자 단위 입출력

## 문자 스트림의 특징

- 문자 스트림은 텍스트 데이터 처리에 최적화되어 있다.
- 문자 인코딩을 자동으로 처리한다.
- 유니코드 지원으로 다국어 처리가 가능하다.

## 주요 문자 스트림 클래스

- **Reader 계열**
    
    
    | **클래스** | **용도** |
    | --- | --- |
    | FileReader | 파일에서 문자 단위로 읽기 |
    | StringReader | 문자열에서 읽기 |
    | BufferedReader | 버퍼를 이용한 효율적인 읽기 (`readLine()` 제공) |
    | InputStreamReader | 바이트 스트림을 문자 스트림으로 변환 |
- **Writer 계열**
    
    
    | **클래스** | **용도** |
    | --- | --- |
    | FileWriter | 파일에 문자 단위로 쓰기 |
    | StringWriter | 문자열로 쓰기 |
    | BufferedWriter | 버퍼를 이용한 효율적인 쓰기 |
    | OutputStreamWriter | 문자 스트림을 바이트 스트림으로 변환 |

## 문자 스트림 예제

```java
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;

public class CharStreamExample {
	public static void main(String[] args) {
		try (FileReader fr = new FileReader("input.txt");
				FileWriter fw = new FileWriter("output.txt")) {
				
				int character;
				// 파일 끝(-1)까지 한 문자씩 읽기
				while ((character = fr.read()) != -1) {
					fw.write(character);
				}
				System.out.println("텍스트 파일 복사 완료");
			
		} catch (IOException e) {
			System.out.println("파일 처리 중 오류: " + e.getMessage());
		}
	}
}
```

# 표준 입출력 (System.in, System.out, System.err)

## 표준 스트림

- 콘솔 기반 입출력을 위해 자바가 제공하는 세 가지 표준 스트림이다.
- **System.in**
    - 표준 입력 스트림이다. (`InputStream`)
    - 키보드로부터 입력을 받는다.
    - 주로 `Scanner` 또는 `BufferedReader`와 함께 사용한다.
- **System.out**
    - 표준 출력 스트림이다. (`PrintStream`)
    - 콘솔에 일반 메시지를 출력한다.
    - `println()`, `print()`, `printf()` 메서드를 제공한다.
- **System.err**
    - 표준 오류 스트림이다. (`PrintStream`)
    - 오류 메시지를 출력할 때 사용한다.
    - 일반 출력과 분리되어 관리된다.

## 표준 입출력 예제

```java
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;

public class SystemIOExample {
	public static void main(String[] args) {
		// System.in을 BufferedReader로 감싸기
		BufferedReader br = new BufferedReader(
				new InputStreamReader(System.in)
		);
		
		try {
			// System.out으로 프롬프트 출력
			System.out.print("이름을 입력하세요: ");
			String name = br.readLine();
			
			System.out.print("나이를 입력하세요: ");
			int age = Integer.parseInt(br.readLine());
			
			// 정상 출력
			System.out.println("안녕하세요, " + name + "님!");
			System.out.println("당신은 " + age + "살 입니다.");
			
			// 오류 출력 예시
			if (age < 0) {
				System.err.println("오류: 나이는 음수일 수 없습니다.");
			}
		
		} catch (IOException e) {
			System.err.println("입력 오류: " + e.getMessage());
		} catch (NumberFormatException e) {
			System.err.println("숫자 형식 오류: " + e.getMessage());
		}
	}
}
```

# Scanner 클래스 활용

- `Scanner`는 다양한 타입의 입력을 쉽게 처리할 수 있는 유틸리티 클래스이다.
- `nextInt()`, `nextDouble()` 등을 사용한 후 `nextLine()`을 호출하기 위해서는 버퍼를 비워야 한다.
- `hasNext()` 메서드로 입력 여부를 확인할 수 있다.
- 파일 입력에도 사용이 가능하다. `new Scanner(new File(”input.txt”))`
- 활용 예제
    
    ```java
    import java.util.Scanner;
    
    public class ScannerExample {
    	public static void main(String[] args) {
    		Scanner sc = new Scanner(System.in);
    		
    		try {
    			System.out.print("정수를 입력하세요: ");
    			int intValue = sc.nextInt();
    			
    			System.out.print("실수를 입력하세요: ");
    			double doubleValue = sc.nextDouble();
    			
    			System.out.print("true/false를 입력하세요: ");
    			boolean boolValue = sc.nextBoolean();
    			
    			// 버퍼 비우기 (nextLine() 전에 필요)
    			sc.nextLine();
    			
    			System.out.print("문자열을 입력하세요: ");
    			String stringValue = sc.nextLine();
    			
    			System.out.println("\n=== 입력 결과 ===");
    			System.out.println("정수: " + intValue);
    			System.out.println("실수: " + doubleValue);
    			System.out.println("불린: " + boolValue);
    			System.out.println("문자열: " + stringValue);
    		
    		} finally {
    			sc.close();
    		}
    	}
    }
    ```
    

# 파일 입출력

## File 클래스 개요

- 파일 입출력은 데이터의 영속성을 보장하는 핵심 기능이다.
- `File` 클래스는 파일 자체가 아니라, 파일/디렉토리에 대한 추상 경로를 표현한다.
- 따라서 `File` 인스턴스를 만들었다고 해서 실제 폴더에 파일이 생성되는 것은 아니다.
- `java.io.File` 클래스는 파일의 크기, 파일의 접근 권한, 파일의 삭제, 이름 변경 등의 작업을 할 수 있는 기능을 제공한다.
- 디렉토리(폴더) 역시 파일로서 취급된다.

```java
// 파일 경로로 File 객체 생성
File file1 = new File("myfile.txt");
File file2 = new File("/path/to/myfile.txt");

// 부모 디렉터리와 파일명으로 생성
File parent = new File("/path/to");
File child = new File(parent, "myfile.txt");

// 문자열 경로로 생성
File file4 = new File("/path/to", "myfile.txt");
```

## 활용 예제

**파일 정보 조회 예제**

```java
import java.io.File;
import java.io.IOException;

public class FileInfo {
	public static void main(String[] args) {
		if (args.length != 1) {
			Systemo.ut.println("사용법: java FileInfo 파일이름");
			System.exit(0);
		}
		
		File f = new File(args[0]);
		if (f.exists()) { // 파일이 존재할 경우
			System.out.println("length: " + f.length());
			System.out.println("canRead: " + f.canRead());
			System.out.println("canWrite: " + f.canWrite());
			System.out.println("getAbsolutePath: " + f.getAbsolutePath());
			
			try {
				// AbsolutePath() 와 동일한 절대위치이지만, 더 자세한 실제 위치로 표현한다.
				System.out.println("getCanonicalPath: " + f.getCanonicalPath());
			} catch (IOException e) {
				System.out.println(e);
			}
			
			System.out.println("getName: " + f.getName());
			System.out.println("getParent: " + f.getParent());
			System.out.println("getPath: " + f.getPath());
		
		} else { // 파일이 존재하지 않을 경우
			System.out.println("파일이 존재하지 않습니다.");
		}
	}
}
```

**파일 삭제 예제**

```java
import java.io.*;

public class FileDelete {
	public static void main(String[] args) {
		if (args.length != 1) {
			System.out.println("사용법: java FileDelete 파일이름");
			System.exit(0);
		}
		
		File f = new File(args[0]);
		if (f.exists()) {
			boolean deleteFlag = f.delete();
			if (deleteFlag) {
				System.out.println("파일 삭제를 성공하였습니다.");
			} else {
				System.out.println("파일 삭제를 실패하였습니다.");
			}
		} else {
			System.out.println("파일이 존재하지 않습니다.");
		}
	}
}
```

**디렉토리 목록 조회 예제**

```java
import java.io.*;

public class FileList {
	public static void main(String[] args) {
		if (args.length != 1) {
			System.out.pritln("사용법: java FileList 디렉토리 이름");
			System.exit(0);
		}
		
		File f = new File(args[0]);
		if (!f.exists()) {
			System.out.println("디렉토리가 존재하지 않습니다.");
			System.exit(0);
		}
		
		if (f.isDirectory()) {
			File[] fileList = f.listFiles();
			for (int i = 0; i < fileList.length; i++) {
				System.out.print(fileList[i].getName());
				System.out.print("\t");
				if (fileList[i].isDirectory()) {
					System.out.println("디렉토리");
				} else {
					System.out.print("파일");
					System.out.print("\t");
					System.out.println(fileList[i].length());
				}
			}
		} else {
			System.out.println("디렉토리가 아닙니다.");
		}
	}
}
```

**임시 파일 생성과 삭제**

```java
import java.io.*;

public class TempFile {
	public static void main(String[] args) {
		try {
				File tempFile = File.createTempFile("tmp_", ".dat");
				System.out.println("임시 파일 생성: " + tempFile.getAbsolutePath());
				System.out.println("30초 동안 멈춰있습니다.");
				
				try {
					Thread.sleep(30000);
				} catch (InterruptedException e) {
					System.out.println(e);
				}
				
				tempFile.deleteOnExit(); // JVM이 종료될 대 임시파일 자동으로 삭제
		
		} catch (IOException e) {
				System.out.println(e);
		}
	}
}
```

- `createTempFile()`로 생성한 임시 파일은 `deleteOnExit()`을 사용하여 프로그램 종료 시 자동으로 삭제되도록 할 수 있다.

## 파일 입출력 과정

- **파일 읽기 과정**
    - 파일과의 연결 생성(FileInputStream/FileReader)
    - 데이터 읽기(read() 메서드)
    - 리소스 해제(close() 메서드)
- **파일 쓰기 과정**
    - 파일과의 연결 생성(FileOutputStream/FileWriter)
    - 데이터 쓰기(write() 메서드)
    - 리소스 해제(close() 메서드)

- **파일 복사 예제 (바이트 단위)**
    
    ```java
    import java.io.*;
    
    public class FileCopyByte {
    	public static void main(String[] args) {
    		String sourceFile = "source.pdf";
    		String destFile = "destination.pdf";
    		
    		try (FileInputStream fis = new FileInputStream(sourceFile);
    				FileOutputStream fos = new FileOutputStream(destFile);
    				BufferedInputStream bis = new BufferedInputStream(fis);
    				BufferedOutputStream bos = new BufferedOutputStream(fos)
    				// 한 번에 정의하는 것도 가능하다.
    				/* BufferedInputStream bis = new BufferedInputStream(
    								new FileInputStream(sourceFile);
    				BufferedOutputStream bos = new BufferedOutputStream(
    								new FileOutputStream(destFile) */) {
    				
    				byte[] buffer = new byte[1024];
    				int bytesRead;
    				
    				// 버퍼 단위로 읽고 쓰기
    				while ((bytesRead = bis.read(buffer)) != -1) {
    					bos.write(buffer, 0, bytesRead);
    				}
    				
    				System.out.println("파일 복사 완료: " + sourceFile + " -> " + destFile);
    			
    		} catch (IOException e) {
    			System.out.println("파일 복사 실패: " + e.getMessage());
    		}
    	}
    }
    ```
    
- **텍스트 파일 처리 예제 (문자 단위)**
    
    ```java
    import java.io.*;
    
    public class TextFileProcessor {
    	public static void main(String[] args) {
    		String inputFile = "input.txt";
    		String outputFile = "output.txt";
    		
    		try (BufferedReader br = new BufferedReader(new FileReader(inputFile));
    				PrintWriter pw = new PrintWriter(new FileWriter(outputFile))) {
    				
    				String line;
    				int lineNumber = 1;
    				
    				// 한 줄씩 읽어서 처리
    				while ((line = br.readLine()) != null) {
    					// 줄 번호 추가하여 쓰기
    					pw.println(lineNumber + ": " + line);
    					lineNumber++;
    				}
    				
    				System.out.println("텍스트 파일 처리 완료!");
    				System.out.println("총 " + (lineNumber - 1) + "줄 처리됨");
    			
    		} catch (IOException e) {
    			System.out.println("파일 처리 오류: " + e.getMessage());
    		}
    	}
    }
    ```
    

# 보조 스트림 (Filter Stream)

## 보조 스트림의 개념

- 보조 스트림은 기본 스트림에 추가 기능을 제공하는 데코레이터 패턴의 구현이다.

## 주요 보조 스트림

1. **변환 스트림**
    - 바이트 ↔ 문자 스트림 변환
    - InoutStreamReader / OutputStreamWriter
2. **Buffered Streams (버퍼링 스트림)**
    - 입출력 성능 향상 (내부 버퍼 사용)
    - BufferedInputStream / BufferedOutputStream
    - BufferedReader / BufferedWriter
3. **Data Streams (데이터 스트림)**
    - 기본 데이터 타입 입출력 (`int`, `double` 등)
    - DataInputStream / DataOutputStream
4. **Object Streams (객체 스트림)**
    - 객체 직렬화/역직렬화
    - ObjectInputStream / ObjectOutputStream
5. **Print Streams (출력 스트림)**
    - 형식화된 출력, 자동 flush 기능
    - PrintStream, PrintWriter

## 데이터 타입 입출력 예제

```java
import java.io.*;

public class DataStreamExample {
	public static void main(String[] args) {
		String filename = "data.dat";
		
		// 데이터 쓰기
		try (DataOutputStream dos = new DataOutputStream(
						new BufferedOutputStream(new FileOutputStream(filename)))) {
				
				dos.writeInt(100);
				dos.writeDouble(3.14159);
				dos.writeBoolean(true);
				dos.writeUTF("안녕하세요, Java IO!");
				
				System.out.println("데이터 저장 완료");
		
		} catch (IOException e) {
			System.out.println("쓰기 오류: " + e.getMessage());
		}
		
		// 데이터 읽기
		try (DataInputStream dis = new DataInputStream(
						new BufferedInputStream(new FileInputStream(filename)))) {
				
				int intValue = dis.readInt();
				double doubleValue = dis.readDouble();
				boolean boolValue = dis.readBoolean();
				String stringValue = dis.readUTF();
				
				System.out.println("\n=== 읽은 데이터 ===");
				System.out.println("정수: " + intValue);
				System.out.println("실수: " + doubleValue);
				System.out.println("불린: " + boolValue);
				System.out.println("문자열: " + stringValue);
		
		} catch (IOException e) {
			System.err.println("읽기 오류: " + e.getMessage());
		}
	}
}
```

## BufferedReader와 PrintWriter 활용 예제

```java
import java.io.*;

public class LogFileProcessor {
	public static void main(String[] args) {
		String inputFile = "access.log";
		String outputFile = "errors.log";
		
		try (BufferedReader br = new BufferedReader(new FileReader(inputFile));
				PrintWriter pw = new PrintWriter(
								new BufferedWriter(new FileWriter(outputFile)))) {
				
				String line;
				int totalLines = 0;
				int errorLines = 0;
				
				while ((line = br.readLine()) != null) {
					totalLines++;
					
					// ERROR를 포함한 라인만 추출
					if (line.contains("ERROR")) {
						pw.println("[" + totalLines + "]" + line);
						errorLines++;
					}
				}
				
				// 통계 정보 추가
				pw.println("\n=== 로그 분석 결과 ===");
				pw.println("전체 라인: " + totalLines);
				pw.println("오류 라인: " + errorLines);
				pw.printf("오류율: %.2f%%\n", (errorLines * 100.0 / totalLines));
				
				System.out.println("로그 파일 처리 완료!");
				System.out.println("오류 로그가 " + outputFile + "에 저장되었습니다.");
		
		} catch (IOException e) {
			System.out.println("파일 처리 오류: " + e.getMessage());
		}
	}
}
```

# 직렬화와 ObjectStream

## 직렬화(Serialization)란?

- 객체를 바이트 스트림으로 변환하여 파일 또는 네트워크로 전송하거나 저장하는 기술이다.
- 반대로 바이트 스트림을 객체로 복원하는 것을 역직렬화(Deserialization)라 한다.
- 직렬화 가능한 대상을 읽고 쓸 수 있다. (ObjectInputStream, ObjectOutputStream)
    - 직렬화 가능한 대상: 기본형 타입 - `java.io.Serializable` 인터페이스를 구현하고 있는 객체
    - 해당 인터페이스는 마커 인터페이스(메서드가 없음)로, JVM이 직렬화 가능 객체임을 판단하도록 한다.
- static 필드는 인스턴스와 무관하므로 직렬화 대상이 아니다.
- 객체 직렬화는 JVM 내부 또는 순수 Java 환경에서는 객체 상태를 저장하거나 전송할 때 편리하다.
- 하지만 다양한 언어와 시스템 간의 데이터 교환이나 높은 보안 및 성능이 요구되는 환경에서는 JSON, XML 등 더 효율적이고 안전한 대안이 선호된다.

## 예제 코드

```java
import java.io.*;

// 직렬화 가능한 User 클래스
class User implements Serializable {
	private static final long serialVersionUID = 1L;
	
	private String name;
	private int age;
	private String email;
	
	public User(String name, int age, String email) {
		this.name = name;
		this.age = age;
		this.email = email;
	}
	
	// getter, setter, toString ...
}

public class ObjectStreamExample {
	public static void main(String[] args) {
		try {
				// 객체 쓰기
				ObjectOutputStream oos = new ObjectOutputStream(
								new FileOutputStream("user.dat"));
				
				User user = new User("홍길동", 25, "hong@example.com");
				oos.writeObject(user);
				oos.close();
				
				// 객체 읽기
				ObjectInputStream ois = new ObjectInputStream(
								new FileInputStream("user.dat"));
				
				User readUser = (User) ois.readObject();
				System.out.println("읽어온 객체: " + readUser);
				ois.close();
		
		} catch (IOException | ClassNotFoundException e) {
				e.printStackTrace();
		}
	}
}
```
