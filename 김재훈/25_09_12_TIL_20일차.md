# DDL

## DDL 개요

<img width="1642" height="1528" alt="Image" src="https://github.com/user-attachments/assets/fb877b76-8886-4b68-a9d5-fa91902cc195" />

# CREATE TABLE

## 기본 문법

```sql
CREATE TABLE 테이블이름 (
	필드이름1 필드타입1 [제약조건],
	필드이름2 필드타입2 [제약조건],
	...
	[테이블 제약조건]
);
```

- 테이블 이름은 복수를 사용하는 것이 일반적이다.

## 제약조건 (Constraints)

| **제약조건** | **설명** |
| --- | --- |
| NOT NULL | NULL을 허용하지 않는다. |
| UNIQUE | 중복된 값을 허용하지 않는다. |
| PRIMARY KEY | NOT NULL + UNIQUE |
| FOREIGN KEY | 다른 테이블 참조 |
| DEFAULT | 기본값을 설정한다. |
| CHECK | 값의 범위를 제한한다. |
| AUTO_INCREMENT | 자동으로 증가하며, 한 테이블에 하나만 설정 가능하다. |
- CHECK 제약조건 주의사항
    - MySQL 8.0.16 이전 버전에서는 CHECK 제약조건이 파싱은 되지만 실제로 작동하지 않는다.
    - MySQL 8.0.16 이후부터 CHECK 제약조건이 완전히 지원된다.

## 테이블 생성 예제

```sql
-- 학생(id, name, age, email, created_date)
CREATE TABLE students (
	id int primary key auto_increment, # 기본키 (반드시 설정해야 한다.)
    name varchar(50) NOT NULL,
    age int,
    email varchar(100) UNIQUE,
    created_date DATETIME DEFAULT current_timestamp
);
# DATETIME은 TIMEZONE을 가지고 있지 않고, TIMESTAMP는 TIMEZONE을 가지고 있다.
```

# INSERT INTO

- 데이터를 삽입할 때 사용한다.
- 기본 문법
    
    ```sql
    INSERT INTO 테이블명 (컬럼명..) VALUES (값..)
    # 컬럼이 나열된 순서대로 값이 나열되어야 한다.
    INSERT INTO 테이블명 VALUES (값..)
    # 컬럼명을 생략할 경우, 테이블에 존재하는 모든 컬럼에 대해 순서대로 값이 나열되어야 한다.
    ```
    
- 예제
    
    ```sql
    INSERT INTO students (name, age) VALUES ('jaehun', 20);
    INSERT INTO students (name, age) VALUES (20);
    # 오류 발생: 컬럼의 개수와 값의 개수가 일치하지 않기 때문에 오류가 발생한다.
    INSERT INTO students (age) VALUES (20);
    # 오류 발생: name은 NOT NULL인데 NULL이 들어가서 오류가 발생한다.
    INSERT INTO students VALUES ('jaehun', 20);
    # 오류 발생: 컬럼명을 생략할 경우, 테이블에 존재하는 모든 컬럼에 대해 순서대로 값이 나열되어야 한다.
    ```
    

# 인덱스 (INDEX)

## 인덱스란?

- 데이터 검색 속도를 향상시키기 위한 자료구조이다.
- WHERE 절에 사용되는 컬럼을 기준으로 인덱스를 생성하는 것이 유용하다.
- 과도한 인덱스는 오히려 성능 저하를 발생시킬 수 있으니 꼭 필요한 컬럼만 생성해야 한다.

## 인덱스 생성과 삭제

```sql
-- 인덱스 생성
CREATE INDEX employees_hire_date_idx 
ON employees(hire_date);

-- 복합 인덱스
CREATE INDEX emp_dept_sal_idx 
ON employees(department_id, salary);

-- 인덱스 확인
SHOW INDEX FROM employees;

-- 인덱스 삭제
ALTER TABLE employees 
DROP INDEX employees_hire_date_idx;
```

## 실행 계획 확인

```sql
-- 인덱스 사용 전
EXPLAIN SELECT * FROM employees 
WHERE hire_date = '2005-01-01';

-- 인덱스 생성
CREATE INDEX emp_hire_idx ON employees(hire_date);

-- 인덱스 사용 후
EXPLAIN SELECT * FROM employees 
WHERE hire_date = '2005-01-01';
```

- 인덱스 사용 전 예시
    
    <img width="960" height="306" alt="Image" src="https://github.com/user-attachments/assets/cbfbf0d0-85c4-4a76-9661-de6e826171c4" />
    
- 인덱스 사용 후 예시
    
    <img width="965" height="302" alt="Image" src="https://github.com/user-attachments/assets/8ecd248e-cf42-4b58-b1e5-e78e0f573743" />
    

> **인덱스 성능 최적화 팁**
> 
> - 인덱스 사용 최적화
>     - 좌변을 변형하면 인덱스를 사용하지 못한다.
>     - WHERE SUBSTRING(hire_date, 1, 4) = ‘2005’ (X)
>     - WHERE hire_date LIKE ‘2005%’ (O)
> - 복합 인덱스 활용
>     - 자주 함께 사용되는 컬럼들을 복합 인덱스로 생성
>     - WHERE 절에서 사용 빈도가 높은 순으로 컬럼 순서 결정
>     - 선택도가 높은 컬럼을 앞에 배치
> - 인덱스 성능 모니터링
>     - SHOW INDEX FROM 테이블명으로 인덱스 상태 확인
>     - EXPLAIN으로 쿼리 실행계획 분석
>     - 불필요한 인덱스는 삭제하여 INSERT/UPDATE 성능 향상

# 데이터베이스 설계

## 설계 단계

1. **요구조건 분석**: 데이터 처리 및 처리 요구 조건
2. **개념석 설계**: E-R 다이어그램, DBMS 독립적
3. **논리적 설계**: 정규화, 목표 DBMS에 맞는 스키마
4. **물리적 설계**: 반정규화, 인덱스 설계
5. **구현**: DDL로 스키마 작성

## 게시판 시스템 요구사항

- 회원 가입, 로그인
- 권한 관리 (일반 사용자, 관리자)
- 글쓰기, 글 목록보기
- 페이징 처리 (10개씩)

## 데이터 분석

**초기 테이블 설계 (정규화 전)**

| **이메일** | **이름** | **암호** | **등록일** | **권한** |
| --- | --- | --- | --- | --- |
| carami@nate.com | 강경미 | 1234 | 2020-01-01 | 일반 |
| urstory@gmail.com | 김성박 | 1234 | 2020-01-01 | 관리자 |

**문제점**: 중복 데이터, 권한이 여러 개일 때 처리 어려움

# 정규화된 테이블 설계

## 테이블 관계도

<img width="803" height="418" alt="Image" src="https://github.com/user-attachments/assets/81b7e9e6-fe2d-4cc7-8f83-20c7f80393fc" />

## 회원 테이블

```sql
DROP TABLE IF EXISTS user;

CREATE TABLE user (
	user_id INT PRIMARY KEY AUTO_INCREMENT,
	email VARCHAR(255) NOT NULL UNIQUE,
	name VARCHAR(50) NOT NULL,
	password VARCHAR(500) NOT NULL,
	regdate TIMESTAMP DEFAULT NOW(),
	INDEX idx_email(email)
);
```

## 권한 테이블

```sql
DROP TABLE IF EXISTS role;

CREATE TABLE role (
	role_id INT PRIMARY KEY,
	name VARCHAR(20) NOT NULL
);

-- 기본 권한 데이터
INSERT INTO role(role_id, name) VALUES
	(1, 'ROLE_USER'),
	(2, 'ROLE_ADMIN');
```

## 회원-권한 매핑 테이블

```sql
DROP TABLE IF EXISTS user_role;

CREATE TABLE user_role (
	user_id INT,
	role_id INT,
	PRIMARY KEY(user_id, role_id),
	FOREIGN KEY(user_id) REFERENCES user(user_id) ON DELETE CASCADE,
	FOREIGN KEY(role_id) REFERENCES role(role_id)
);

# UPDATE CASCADE: 부모 키 변경 시 자식도 자동 변경
# DELETE CASCADE: 부모 삭제 시 자식도 삭제
```

## 게시판 테이블

```sql
DROP TABLE IF EXISTS board;

CREATE TABLE board (
	board_id INT PRIMARY KEY AUTO_INCREMENT,
	title VARCHAR(100) NOT NULL,
	content TEXT NULL,
	user_id INT NOT NULL,
	regdate TIMESTAMP DEFAULT NOW(),
	view_cnt INT DEFAULT 0,
	FOREIGN KEY(user_id) REFERENCES user(user_id),
	INDEX idx_regdate (regdate DESC)
);
```

# 트랜잭션 (Transaction)

## 트랜잭션이란?

- DB에서 하나의 작업으로 처리되는 논리적 작업 단위

## ACID 특성

| **특성** | **설명** |
| --- | --- |
| Atomicity | 원자성 - 전부 성공 또는 전부 실패 |
| Consistency | 일관성 - 데이터 무결성 유지 |
| Isolation | 독립성 - 동시 실행 시 간섭 없음 |
| Durability | 지속성 - 완료 후 영구 저장 |

## 트랜잭션 제어

```sql
-- AutoCommit 확인
SELECT @@AUTOCOMMIT;

-- AutoCommit 해제
SET AUTOCOMMIT = 0; # 모든 쿼리가 트랜잭션 안에서 실행된다.

-- 트랜잭션 시작
START TRANSACTION;

-- SQL 실행
INSERT INTO user (email, name, password)
VALUES ('test@test.com', '테스트', '1234');

-- 커밋 또는 롤백
COMMIT; -- 변경사항 확정
ROLLBACK; -- 변경사항 취소

-- AutoCommit 설정
SET AUTOCOMMIT = 1;
```

# 실제 쿼리 구현

## 회원가입 (트랜잭션 필요)

```sql
START TRANSACTION;

-- 사용자 등록
INSERT INTO user (email, name, password, regdate)
VALUES ('urstory@gmail.com', '김성박', '1234', NOW());

-- 기본 권한 부여
INSERT INTO user_role (user_id, role_id)
VALUES (LAST_INSERT_ID(), 1);

COMMIT;
```

## 로그인

```sql
-- 사용자 정보와 권한 조회
SELECT
	u.user_id,
	u.email,
	u.name,
	u.password,
	r.name AS role_name
FROM user u
INNER JOIN user_role ur ON u.user_id = ur.user_id
INNER JOIN role r ON ur.role_id = r.role_id
WHERE u.email = 'urstory@gmail.com';
```

## 게시물 저장

```sql
INSERT INTO board (title, content, user_id, regdate)
VALUES ('제목1', '내용1', 1, NOW());
```

## 게시물 목록 (페이징)

```sql
-- 1페이지 (0-9)
SELECT
	board_id,
	title,
	content,
	user_id,
	regdate,
	view_cnt
FROM board
ORDER BY board_id DESC
LIMIT 0, 10;

-- 2페이지 (10-19)
SELECT * FROM board
ORDER BY board_id DESC
LIMIT 10, 10;
```

## 게시물 조회 (트랜잭션 필요)

```sql
START TRANSACTION;

-- 게시물 읽기
SELECT
	board_id,
	title,
	content,
	user_id,
	regdate,
	view_cnt
FROM board
WHERE board_id = 1;

-- 조회수 증가
UPDATE board
SET view_cnt = view_cnt + 1
WHERE board_id = 1;

COMMIT;
```

# ALTER TABLE

## 컬럼 추가/삭제/수정

```sql
-- 컬럼 추가
ALTER TABLE board
ADD COLUMN updated_date TIMESTAMP NULL;

-- 컬럼 수정
ALTER TABLE board
MODIFY COLUMN title VARCHAR(200) NOT NULL;

-- 컬럼 이름 변경
ALTER TABLE board
CHANGE COLUMN content contents TEXT;

-- 컬럼 삭제
ALTER TABLE board
DROP COLUMN updated_date;
```

## 제약조건 추가/삭제

```sql
-- 외래키 추가
ALTER TABLE board
ADD CONSTRAINT fk_board_user
FOREIGN KEY (user_id) REFERENCES user(user_id);

-- 인덱스 추가
ALTER TABLE board
ADD INDEX idx_title (title);

-- 제약조건 삭제
ALTER TABLE board
DROP FOREIGN KEY fk_board_user;
```

---

# JDBC 프로그래밍

## JDBC란?

- JDBC(Java Database Connectivity)
- Java 애플리케이션에서 데이터베이스에 접속하고 SQL을 실행하기 위한 표준 API이다.

<img width="1294" height="700" alt="Image" src="https://github.com/user-attachments/assets/43c90332-2d8b-4185-bc1e-ddfe13a39f68" />

## JDBC 특징

- Java의 표준 인터페이스(java.sql, javax.sql 패키지)
- 데이터베이스 독립적인 프로그래밍
- 벤더별 JDBC 드라이버 제공
- SQL 문장 실행 및 결과 처리

## JDBC 구성 요소

| **구성 요소** | **설명** |
| --- | --- |
| DriverManager | JDBC 드라이버 관리, Connection 생성 |
| Connection | 데이터베이스 연결 |
| Statement | SQL 문장 실행 |
| PreparedStatement | 미리 컴파일된 SQL 실행 |
| CallableStatement | 저장 프로시저 실행 |
| ResultSet | SELECT 결과 저장 |

# JDBC 환경 설정

## MySQL JDBC 드라이버 설정

- **Maven 의존성 추가**
    
    ```java
    <dependency>
        <groupId>mysql</groupId>
        <artifactId>mysql-connector-java</artifactId>
        <version>8.0.31</version>
    </dependency>
    ```
    
- **Gradle 의존성 추가**
    
    ```java
    dependencies {
        implementation("com.mysql:mysql-connector-j:8.3.0")
    }
    ```
    

## JDBC URL 형식

```java
jdbc:mysql://[host]:[port]/[database]?[parameters]

// 예시
jdbc:mysql://localhost:3306/examplesdb?useSSL=false&serverTimezone=UTC
```
