# 스레드 간 통신

## wait()와 notify()

- 스레드 간 협력을 위한 매커니즘이다. 반드시 `synchronized` 블록 안에서 호출해야 한다.
    - `wait()`: 스레드를 대기 상태로 전환한다.
        - `sleep()`은 락을 유지한 채 스레드를 멈춘다.
        - `wait()`은 락을 해제하고 다른 스레드가 자원을 사용할 수 있도록 한다.
    - `notify()`: 대기 중인 스레드 하나를 깨운다.
    - `notifyAll()`: 모든 대기 스레드를 깨운다.

## 생산자-소비자 패턴

- 생산자 소비자 문제
    - 생산자 스레드와 소비자 스레드가 특정 자원을 함께 생산하고, 소비하면서 발생하는 문제이다.
    - while문과 `wait()`, `notifyAll()`을 활용하여 교착 없이 구현할 수 있다.
    - 하나만 깨우면 다른 스레드가 굶주릴 수 있기 때문에 `notifyAll()`을 사용하는 것이 안정적이다.
    - 자바에서는 `BlockingQueue`를 사용하면 직접 구현하는 것보다 안전하고 간단하다.

```java
public class ProducerConsumer {
	private List<Integer> buffer = new ArrayList<>();
	private final int MAX_SIZE = 5;
	private final Object lock = new Object();
	
	// 생산자
	public void produce(int value) throws InterruptedException {
		synchronized(lock) {
			while (buffer.size() >= MAX_SIZE) {
				System.out.println("버퍼가 가득 참, 대기 중 ...");
				lock.wait(); // 버퍼가 빌 때까지 대기
			}
			
			buffer.add(value);
			System.out.println("생산: " + value + ", 버퍼 크기: " + buffer.size());
			lock.notifyAll(); // 대기 중인 소비자 깨우기
		}
	}
	
	// 소비자
	public int consume() throws InterruptedException {
		synchronized(lock) {
			while (buffer.isEmpty()) {
				System.out.println("버퍼가 비어있음, 대기 중 ...");
				lock.wait(); // 데이터가 올 때까지 대기
			}
			
			int value = buffer.remove(0);
			System.out.println("소비: " + value + ", 버퍼 크기: " + buffer.size());
			lock.notifyAll(); // 대기 중인 생산자 꺠우기
			return value;
		}
	}
}
```

## 예제) 프린터 스풀러

```java
public class PrinterSpooler {
	private Queue<String> printQueue = new LinkedList<>();
	private boolean isPrinting = false;
	
	// 문서 추가
	public synchronized void addDocument(String doc) {
		printQueue.offer(doc);
		System.out.println("문서 추가: " + doc);
		
		if (!isPrinting) {
			notify(); // 프린터 깨우기, notifyAll()이 더 안정적이다.
		}
	}
	
	// 인쇄 작업
	public synchronized void print() throws InterruptedException {
		while (true) {
			while (printQueue.isEmpty()) {
				System.out.println("프린터 대기 중 ...");
				wait(); // 문서를 기다림
			}
			
			isPrinting = true;
			String doc = printQueue.poll();
			System.out.println("인쇄 시작: " + doc);
			
			Thread.sleep(2000); // 인쇄 시뮬레이션
			
			System.out.println("인쇄 완료: " + doc);
			isPrinting = false;
		}
	}
}
```

# 스레드 제어

## 스레드 생명 주기

<img width="562" height="325" alt="Image" src="https://github.com/user-attachments/assets/59246e22-dc75-4d8f-8561-786bc645547d" />

- 스레드는 다음과 같은 상태를 가진다.
    1. **NEW** : 스레드 객체 생성
    2. **RUNNABLE** : 실행 가능 상태
    3. **RUNNING**: 실제 실행 상태
    4. **BLOCKED** : 동기화 블록 진입 대기
    5. **WAITING** : 무기한 대기
    6. **TIMED_WAITING** : 시간 제한 대기
    7. **TERMINATED** : 종료

## join() 메서드

- 다른 스레드의 종료를 기다린다.
- `join(timeout)`으로 특정 시간만 기다릴 수도 있다.

```java
public class JoinExample {
	public static void main(String[] args) throws InterruptedException {
		Thread worker = new Thread(() -> {
			System.out.println("작업 시작");
			try {
				Thread.sleep(3000); // 3초 작업
			} catch (InterruptedException e) {
				e.printStackTrace();
			}
			System.out.println("작업 완료");
		});
		
		worker.start();
		
		System.out.println("작업자 스레드 종료 대기 ...");
		worker.join(); // worker 스레드가 끝날 때까지 대기
		System.out.println("모든 작업 완료!");
	}
}
```

## interrupt() 메서드

- 스레드를 강제로 종료시키지 않고 중단 요청 신호를 보낸다.
- `sleep()`, `wait()` 상태일 경우 `InterruptedException`이 발생한다.
- 안전한 종료를 위해 flag 패턴과 함께 사용하기도 한다.

```java
public class InterruptExample {
	public static void main(String[] args) throws InterruptedException {
		Thread worker = new Thread(() -> {
			try {
				for (int i = 1; i <= 10; i++) {
					System.out.println("작업 진행: " + i + "/10");
					Thread.sleep(1000);
				}
			} catch (InterruptedException e) {
				System.out.println("작업이 중단되었습니다!");
				return;
			}
			System.out.println("작업 완료");
		});
		
		worker.start();
		
		Thread.sleep(3500); // 3.5초 대기
		worker.interrupt(); // 작업 중단 요청
	}
}
```

## 우선순위 설정

- Thread.MIN_PRIORITY(1) ~ Thread.MAX_PRIORITY(10)
- 기본값은 Thread.NORM_PRIORITY(5) 이다.
- 운영체제 스케줄러에 따라 무시될 수도 있다.
    - 자바에서 우선순위는 “힌트”일 뿐, 반드시 반영되지는 않는다.

```java
public class PriorityExample {
	public static void main(String[] args) {
		Thread highPriority = new Thread(() -> {
			for (int i = 0; i < 5; i++) {
				System.out.println("높은 우선순위: " + i);
			}
		});
		
		Thread lowPriority = new Thread(() -> {
			for (int i = 0; i < 5; i++) {
				System.out.println("낮은 우선순위: " + i);
			}
		});
		
		highPriority.setPriority(Thread.MAX_PRIORITY); // 10
		lowPriority.setPriority(Thread.MIN_PRIORITY); // 1
		
		highPriority.start();
		lowPriority.start();
	}
}
```

# 데드락과 해결 방법

## 데드락이란?

- **데드락(Deadlock)**은 둘 이상의 스레드가 서로 가진 리소스를 기다리며 무한 대기하는 상태이다.

<img width="300" height="181" alt="Image" src="https://github.com/user-attachments/assets/44163884-4916-4ee8-8e23-d61737f61010" />

## 데드락 발생 조건

1. **상호 배제**: 리소스를 한 번에 한 스레드만 사용한다.
2. **점유와 대기**: 리소스를 점유하면서 다른 리소스를 대기한다.
3. **비선점**: 강제로 리소스를 빼앗을 수 없다.
4. **순환 대기**: 리소스 대기가 순환 구조이다.

## 데드락 예제

```java
public class DeadlockExample {
	private final Object lock1 = new Object();
	private final Object lock2 = new Object();
	
	public void method1() {
		synchronized(lock1) {
			System.out.println(Thread.currentThread().getName() + ": lock1 획득");
			
			try {
				Thread.sleep(1000);
			} catch (InterruptedException e) {}
			
			synchronized(lock2) {
				System.out.println(Thread.currentThread().getName() + ": lock2 획득");
			}
		}
	}
	
	public void method2() {
		synchronized(lock2) {
			System.out.println(Thread.currentThread().getName() + ": lock2 획득");
			
			try {
				Thread.sleep(1000);
			} catch (InterruptedException e) {}
			
			synchronized(lock1) {
				System.out.println(Thread.currentThread().getName() + ": lock1 획득");
			}
		}
	}
}
```

## 데드락 해결 방법

**방법1: 락 순서 통일**

```java
public class DeadlockSolution {
	private final Object lock1 = new Object();
	private final Object lock2 = new Object();
	
	// 항상 같은 순서로 락 획득
	public void method1() {
		synchronized(lock1) {
			synchronized(lock2) {
				// 작업 수행
			}
		}
	}
	
	public void method2() {
		synchronized(lock1) { // 같은 순서!
			synchronized(lock2) {
				// 작업 수행
			}
		}
	}
}
```

**방법2: 타임아웃 설정**

```java
public class TimeoutSolution {
	private final ReentrantLock lock1 = new ReentrantLock();
	private final ReentrantLock lock2 = new ReentrantLock();
	
	public void performTask() throws InterruptedException {
		while (true) {
			if (lock1.tryLock(1, TimeUnit.SECONDS)) {
				try {
					if (lock2.tryLock(1, TimeUnit.SECONDS)) {
						try {
							// 작업 수행
							break;
						} finally {
							lock2.unlock();
						}
					}
				} finally {
					lock1.unlock();
				}
			}
			Thread.sleep(100); // 재시도 전 대기
		}
	}
}
```

# java.util.concurrent 패키지

## ExecutorService

- 스레드 풀을 효율적으로 관리한다.
- 자원 누수 방지를 위해 반드시 `shutdown()`을 호출해야 한다.

```java
import java.util.concurrent.*;

public class ExecutorServiceExample {
	public static void main(String[] args) {
		// 고정 크기 스레드 풀 생성
		ExecutorService executor = Executors.newFixedThreadPool(3);
		
		// 작업 제출
		for (int i = 1; i <= 10; i++) {
			final int taskId = i;
			executor.submit(() -> {
				System.out.println("작업 " + taskId + " 실행 중 - " + 
							Thread.currentThread().getName());
				try {
					Thread.sleep(1000);
				} catch (InterruptedException e) {
					e.printStackTrace();
				}
			});
		}
		
		// 스레드 풀 종료
		executor.shutdown();
		try {
			if (!executor.awaitTermination(60, TimeUnit.SECONDS)) {
				executor.shutdownNow();
			}
		} catch (InterruptedException e) {
			executor.shutdownNow();
		}
	}
}
```

## Future와 Callable

- 결과를 반환하는 비동기 작업

```java
public class FutureExample {
	public static void main(String[] args) throws Exception {
		ExecutorService executor = Executors.newSingleThreadExecutor();
		
		// Callable은 결과를 반환할 수 있음
		Callable<Integer> task = () -> {
			System.out.println("계산 시작 ...");
			Thread.sleep(2000);
			return 42;
		};
		
		Future<Integer> future = executor.submit(task);
		
		System.out.println("다른 작업 수행 ...");
		
		// 결과 대기 및 획득
		Integer result = future.get(); // 블로킹, get(timeout, unit)으로 제한 가능
		System.out.println("계산 결과: " + result);
		
		executor.shutdown();
	}
}
```

## CountDownLatch

- 여러 스레드의 작업 완료를 대기한다.

```java
public class CountDownLatchExample {
	public static void main(String[] args) throws InterruptedException {
		int workerCount = 3;
		CountDownLatch latch = new CountDownLatch(workerCount);
		
		for (int i = 1; i <= workerCount; i++) {
			final int workerId = i;
			new Thread(() -> {
				try {
					System.out.println("Worker " + workerId + " 작업 시작");
					Thread.sleep(workerId * 1000);
					System.out.println("Worekr " + workerId + " 작업 완료");
				} catch (InterruptedException e) {
					e.printStackTrace();
				} finally {
					latch.countDown(); // 카운트 감소
				}
			}).start();
		}
		
		System.out.println("모든 작업자 대기 중 ...");
		latch.await(); // 카운트가 0이 될 때까지 대기
		System.out.println("모든 작업 완료!");
	}
}
```

## ConcurrentHashMap

- 스레드 안전한 HashMap

```java
public class ConcurrentHashMapExample {
	public static void main(String[] args) throws InterruptedException {
		ConcurrentHashMap<String, Integer> map = new ConcurrentHashMap<>();
		
		// 여러 스레드가 동시에 맵 수정
		Thread[] threads = new Thread[10];
		for (int i = 0; i < 10; i++) {
			final int threadId = i;
			threads[i] = new Thread(() -> {
				for (int j = 0; j < 100; j++) {
					map.merge("count", 1, Integer::sum);
					map.put("thread-" + threadId, j);
				}
			});
			threads[i].start();
		}
		
		for (Thread t : threads) {
			t.join();
		}
		
		System.out.println("총 카운트: " + map.get("count")); // 1000
	}
}
```

## BlockingQueue

- 생산자-소비자 패턴 구현

```java
public class BlockingQueueExample {
	public static void main(String[] args) {
		BlockingQueue<String> queue = new ArrayBlockingQueue<>(5);
		
		// 생산자
		Thread producer = new Thread(() -> {
			try {
				for (int i = 1; i <= 10; i++) {
					String item = "Item-" + i;
					queue.put(item); // 큐가 가득 차면 대기
					System.out.println("생산: " + item);
					Thread.sleep(500);
				}
			} catch (InterruptedException e) {
				e.printStackTrace();
			}
		});
		
		// 소비자
		Thread consumer = new Thread(() -> {
			try {
				for (int i = 0; i < 10; i++) {
					String item = queue.take(); // 큐가 비면 대기
					System.out.println("소비: " + item);
					Thread.sleep(1000);
				}
			} catch (InterruptedException e) {
				e.printStackTrace();
			}
		});
		
		producer.start();
		consumer.start();
	}
}
```

## ThreadLocal

- 스레드별 독립적인 변수를 관리할 수 있다.
- 메모리 누수 방지를 위해 반드시 `remove()`를 호출해야 한다.

```java
public class ThreadLocalExample {
	private static final ThreadLocal<SimpleDateFormat> dateFormatter = 
			ThreadLocal.withInitial(() -> new SimpleDateFormat("yyyy-MM-dd"));
	
	public String formatDate(Date date) {
		// 각 스레드가 자신만의 SimpleDateFormat 인스턴스 사용
		return dateFormatter.get().format(date);
	}
	
	public static void main(String[] args) {
		ThreadLocalExample example = new ThreadLocalExample();
		
		// 여러 스레드에서 안전하게 사용
		for (int i = 0; i < 5; i++) {
			new Thread(() -> {
				Date now = new Date();
				String formatted = example.formatDate(now);
				System.out.println(Thread.currentThread().getName() + ": " + formatted);
			}).strat();
		}
	}
}
```

---

# 람다

# 1급 시민(First-Class Citizen)

## 1급 시민의 조건

- 프로그래밍에서 1급 시민이란 다음 조건을 만족하는 것이다.
    1. 변수에 담을 수 있다.
    2. 함수의 인자로 전달할 수 있다.
    3. 함수의 반환값으로 전달할 수 있다.
    - 함수란 자바의 메서드를 의미한다.

## 자바에서의 함수

- 함수형 프로그래밍 언어들은 함수를 1급 시민으로 취급한다.
- 자바 언어는 함수만 따로 존재할 수가 없다. 즉, 함수라는 객체는 존재하지 않는다.
- 대신 메서드(클래스 안에 정의된 함수)와 함수적 인터페이스를 통해 람다를 표현한다.
- 즉, 자바의 람다는 사실상 익명 클래스의 축약 문법이다.

# 프로그래밍 패러다임

## 패러다임 분류

- **명령형 프로그래밍**
    - 무엇(What)을 할 것인지 나타내기보다 **어떻게(How)** 할 것인지 설명하는 방식
        - **절차지향 프로그래밍**: 수행되어야 할 순차적인 처리 과정을 포함하는 방식 (C, C++)
        - **객체지향 프로그래밍**: 객체들의 집합으로 프로그램의 상호작용을 표현(C++, Java, C#)
- **선언형 프로그래밍**
    - 어떻게(How) 할건지를 나타내기보다 **무엇(What)**을 할 것인지 설명하는 방식
        - **함수형 프로그래밍**: 순수 함수를 조합하고 소프트웨어를 만드는 방식(클로저, 하스켈, 리스프)

# 함수형 프로그래밍 특징

## 핵심 개념

> 부수 효과가 없는 순수 함수를 1급 객체로 간주하여 파라미터나 반환값으로 사용할 수 있으며, 참조 투명성을 지킬 수 있다.
> 

함수형 프로그래밍의 특징을 한 줄로 요약한 것이다.

여기서 키워드는 “**부수 효과**”, “**순수 함수**”, “**1급 객체**”, “**참조 투명성**”이다.

## 부수 효과 (Side Effect)

- 부수효과란 다음과 같은 변화 또는 변화가 발생하는 작업을 의미한다.
    - 변수의 값이 변경된다.
    - 자료 구조를 제자리에서 수정한다.
    - 객체의 필드값을 설정한다.
    - 예외나 오류가 발생하며 실행이 중단된다.
    - 콘솔 또는 파일 I/O가 발생한다.

## 순수 함수 (Pure Function)

- 부수 효과(Side Effect)들을 제거한 함수들을 순수 함수(Pure Function)라 부른다.
- 함수형 프로그래밍에서 사용하는 함수는 이러한 순수 함수들이다.
- 특징
    - Memory or I/O의 관점에서 Side Effect가 없는 함수
    - 함수의 실행이 외부에 영향을 끼치지 않는 함수

## 순수 함수의 장점

- 순수 함수를 이용하면 얻을 수 있는 효과
    - 함수 자체가 독립적이며 Side-Effect가 없기 때문에 Thread에 안정성을 보장받을 수 있다.
    - Thread에 안정성을 보장받아 병렬 처리를 동기화 없이 진행할 수 있다.

# 자바에서의 함수형 프로그래밍

## 익명 구현 객체 활용

- 함수만 따로 존재할 수 없는 자바는 **익명 구현 객체**를 이용할 수 있다.

```java
// Runnable을 구현하는 이름 없는 객체
Runnable r = new Runnable() {
	@Override
	public void run() {
		System.out.println("익명 구현 객체 출력");
	}
};
r.run();
```

## 함수적 인터페이스

- **메서드가 하나**만 있는 인터페이스를 **함수적 인터페이스**라 한다.
    - Runnable 인터페이스는 run() 메서드 하나를 가진다.
    - 이렇게 메서드를 하나만 가진 인터페이스를 함수적 인터페이스라 한다.
    - 함수적 인터페이스는 `@FunctionalInterface` 애노테이션을 붙여서 명시적으로 표현하기도 한다.
    - 해당 애노테이션이 붙은 인터페이스가 메서드를 2개 이상 가질 경우 컴파일 에러가 발생한다.
    - 해당 애노테이션은 문법적 보증일 뿐 필수는 아니다.
    - 하지만 붙여주면 컴파일러가 단일 추상 메서드 규칙을 강제해서 실수를 줄일 수 있다.
    - 추상 메서드는 1개여야 하지만, `default` 메서드와 `static` 메서드는 여러 개 있어도 된다.

# 람다식 (Lambda Expression)

## 람다식 기본 형태

- 함수적 인터페이스를 구현하는 익명 객체를 다음과 같이 생성할 수 있다.
    
    ```java
    Runnable r = () -> {
    	System.out.println("익명 구현 객체 출력");
    };
    r.run();
    ```
    
- 함수적 인터페이스가 가지는 메서드의 **인자를 받아들이는 괄호 부분과 중괄호 사이에 화살표**를 사용하고 나머지 부분은 삭제한다.
- **익명 클래스의 this**는 현재 익명 클래스의 인스턴스를 가리키지만, **람다식의 this**는 람다를 감싸고 있는 외부 클래스의 인스턴스를 가리킨다.
    - → 따라서 람다는 불필요한 클래스 생성을 줄이고, 가독성과 성능이 좋아진다.

## 람다식 문법

```java
(타입 매개변수, ...) -> {실행문; ...}
```

- **규칙**
    - 괄호 안에 타입 매개변수가 0개 이상 올 수 있다.
    - 중괄호 안에 실행문이 여러 줄 올 수 있다.
    - 매개변수 타입을 유추할 수 있을 때는 타입을 생략할 수 있다.

## 예제

**함수적 인터페이스 선언**

```java
@FunctionalInterface
interface PlusFunction {
	int plus(int i, int j);
}
```

**기본 람다식 사용**

```java
public class PlusFunctionExam {
	public static void main(String[] args) {
		PlusFunction plusObj = (int i, int j) -> {
			return i + j;
		};
		int value = plusObj.plus(100, 200);
		System.out.println(value); // 300
	}
}
```

**타입 추론 활용**

```java
public class PlusFunctionExam {
	public static void main(String[] args) {
		PlusFunction plusObj = (i, j) -> {
			return i + j;
		};
		int value = plusObj.plus(100, 200);
		System.out.println(value); // 300
	}
}
```

- `i`와 `j`의 타입을 삭제할 수 있다. JVM과 컴파일러는 추론을 통해 `i`와 `j`가 `int`형인지 알 수 있다.

**축약형 람다식**

```java
public class PlusFunctionExam {
	public static void main(String[] args) {
		PlusFunction plusObj = (i, j) -> i + j;
		int value = plusObj.plus(100, 200);
		System.out.println(value); // 300
	}
}
```

- 중괄호 안에 실행문이 `return`문 하나라면 중괄호와 `return`을 생략할 수 있다.

## 다양한 함수적 인터페이스

```java
// 매개변수가 없는 함수적 인터페이스
@FunctionalInterface
interface Greeting {
	void sayHello();
}

// 매개변수가 하나인 함수적 인터페이스
@FunctionalInterface
interface StringProcessor {
	String process(String str);
}

// 매개변수가 두 개인 함수적 인터페이스
@FunctionalInterface
interface Calculator {
	double calculate(double a, double b);
}

public class LambdaExamples {
	public static void main(String[] args) {
		// 매개변수 없는 람다식
		Greeting greeting = () -> System.out.println("Hello!");
		greeting.sayHello();
		
		// 매개변수가 하나인 람다식 (괄호 생략 가능)
		StringProcessor upperCase = (str) -> str.toUpperCase();
		System.out.println(upperCase.process("hello"); // HELLO
		
		// 매개변수가 두 개인 람다식
		Calculator multiply = (a, b) -> a * b;
		System.out.println(multiply.calculate(5.0, 3.0)); // 15.0
		
		// 복잡한 로직을 가진 람다식
		Calculator complexCalc = (a, b) -> {
			double result = a + b;
			System.out.println("계산 중: " + a + " + " + b);
			return result;
		};
		System.out.println(complexCalc.calculate(10.0, 20.0)); // 30.0
	}
}
```

## 자바 표준 함수적 인터페이스 활용

```java
public class StandardFunctionalInterfaces {
	public static void main(String[] args) {
		// Predicate<T> - 매개변수 하나, boolean 반환
		Predicate<Integer> isEven = num -> num % 2 == 0;
		System.out.println(isEven.test(4)); // true
		System.out.println(isEven.test(5)); // false
		
		// Function<T, R> - 매개변수 하나, 다른 타입 반환
		Function<String, Integer> stringLength = str -> str.length();
		System.out.println(stringLength.apply("Hello")); // 5
		
		// Consumer<T> - 매개변수 하나, 반환값 없음
		Consumer<String> printer = str -> System.out.println("출력: " + str);
		printer.accept("람다식 테스트"); // 출력: 람다식 테스트
		
		// Supplier<T> - 매개변수 없음, 값 반환
		Supplier<Double> randomSupplier = () -> Math.random();
		System.out.println("랜덤 값: " + randomSupplier.get());
		
		// BinaryOperator<T> - 같은 타입 매개변수 두 개, 같은 타입 반환
		BinaryOperator<Integer> add = (a, b) -> a + b;
		System.out.println(add.apply(10, 20)); // 30
	}
}
```

# 람다식과 컬렉션

## 리스트 처리 예제

```java
public class LambdaWithCollections {
	public static void main(String[] args) {
		List<String> names = List.of("김철수", "이영희", "박민수", "정수진", "최영수");
		
		// 1. forEach()로 출력
		System.out.println("=== 전체 이름 출력 ===");
		names.forEach(name -> System.out.println(name));
		// names.forEach(System.out::println);
		
		// 2. 필터링 - '김'으로 시작하는 이름
		System.out.println("\n=== '김'으로 시작하는 이름 ===");
		names.stream()
					.filter(name -> name.startsWith("김"))
					.forEach(System.out::println);
		
		// 3. 변환 - 이름을 대문자로 변환
		System.out.println("\n=== 대문자로 변환된 이름 ===");
		List<String> upperNames = names.stream()
					.map(name -> name.toUpperCase())
					//.collect(Collectors.toList());
					.toList();
		upperNames.forEach(System.out::println);
		
		// 4. 정렬
		System.out.println("\n=== 이름 정렬 ===");
		names.stream()
					.sorted((name1, name2) -> name1.compareTo(name2)) // String::compareTo
					.forEach(System.out::println);
		
		// 5. 숫자 리스트 처리
		List<Integer> numbers = List.of(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);
		
		// 짝수만 필터링하고 제곱한 후 합계 구하기
		int sumOfSquaredEvens = numbers.stream()
						.filter(n -> n % 2 == 0)
						.map(n -> n * n)
						.reduce(0, (a, b) -> a + b);
		System.out.println("\n짝수 제곱의 합: " + sumOfSquaredEvens);
	}
}
```

# 메서드 참조

## 메서드 참조 활용

```java
public class MethodReferenceExample {
	public static void main(String[] args) {
		List<String> names = List.of("alice", "bob", "charlie", "david");
		
		// 1. 정적 메서드 참조: ClassName::staticMethod
		names.forEach(System.out::println); // System.out.println(name)와 동일
		
		// 2. 인스턴스 메서드 참조: instance::method
		names.stream()
					.map(String::toUpperCase) // str -> str.toUpperCase()와 동일
					.forEach(System.out::println);
		
		// 3. 생성자 참조 ClassName::new
		Supplier<List<String>> listSupplier = ArrayList::new; // () -> new ArrayList<>()와 동일
		List<String> newList = listSupplier.get();
		
		// 4. 특정 객체의 메서드 참조: ClassName::instanceMethod
		String prefix = "Name: ";
		Function<String, String> addPrefix = prefix::concat; // str -> prefix.concat(str)와 동일
		
		names.stream()
					.map(addPrefix)
					.forEach(System.out::println);
	}
}
```

# Stream과 람다의 관계

- 람다는 보통 Stream API와 함께 강력하게 사용된다.
- 스트림 연산은 크게 세 가지로 나뉜다.
    1. 생성 (`Stream.of`, `list.stream` 등)
    2. 중간 연산 (`map`, `filter`, `sorted` 등 → 스트림 반환)
        - 원본 리스트를 바꾸지 않고 새로운 스트림을 생성한다.
    3. 최종 연산 (`forEach`, `reduce`, `collect` 등 → 스트림 소모)
- 람다는 스트림의 중간/최종 연산 로직을 간결하게 작성할 수 있도록 한다.
