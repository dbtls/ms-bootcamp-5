# DOM 조작

## DOM 이란?

- Document Object Model
- HTML, XML 문서를 객체(Object) 트리 구조로 표현한 것이다.
- 웹 브라우저는 HTML 문서를 읽어 DOM 트리를 만든 후, JavaScript가 이 DOM 객체들을 조작할 수 있게 해준다.
- 즉, DOM은 HTML 문서를 프로그래밍적으로 다룰 수 있게 만든 인터페이스이다.

<img width="774" height="406" alt="Image" src="https://github.com/user-attachments/assets/c85e8429-d616-41ab-b520-9c5cadca76ce" />

## DOM 선택

- 어떤 요소를 선택할지 찾는 것이다.
- 주요 메서드
    - `getElementById`: 특정 ID를 가진 요소 1개 반환
    - `getElementsByClassName`: HTMLCollection 반환 (유사 배열)
    - `getElementsByTagName`: 태그명으로 찾음 (HTMLCollection 반환)
    - `querySelector`: CSS 선택자 문법 사용, 첫 번째 요소 반환
    - `querySelectorAll`: CSS 선택자 문법 사용, 모든 요소 반환 (NodeList 반환)

```jsx
// ID로 선택
const element = document.getElementById("myId");

// 클래스로 선택
const elements = document.getElementsByClassName("myClass");

// 태그로 선택
const divs = document.getElementsByTagName("div");

// CSS 선택자로 선택 (권장)
const element = document.querySelector("#myId");
const elements = document.querySelectorAll(".myClass");
```

## DOM 조작

- **내용 변경**
    - `textContent`: 순수 텍스트 변경
    - `innerHTML`: HTML 태그까지 포함해서 변경 가능하지만, 악의적인 스크립트 삽입(XSS 공격)에 취약
- **스타일 변경**
    - `element.style.property = value`
    - 직접 스타일을 바꾸지만, 보통 CSS 클래스 추가/제거 방식이 유지보수에 더 용이하다.

```jsx
// 내용 변경
element.textContent = '새로운 텍스트';
element.innerHTML = '<strong>HTML 내용</strong>';

// 스타일 변경
element.style.color = 'red';
element.style.backgroundColor = '#f0f0f0';

// 클래스 조작
element.classList.add('active');
element.classList.remove('inactive');
element.classList.toggle('visible');

// 속성 조작
element.setAttribute('data-id', '123');
element.getAttribute('data-id');
element.removeAttribute('data-id');
```

## 이벤트 처리

- 이벤트: 사용자가 웹 페이지와 상호작용할 때 발생하는 사건
    - 예) 클릭, 입력, 스크롤, 키보드 입력 등

```jsx
// 클릭 이벤트
button.addEventListener('click', function(event) {
	console.log("버튼 클릭됨!");
});

// 여러 이벤트 유형
input.addEventListener('input', (e) => {
	console.log("입력값:", e.target.value);
});

form.addEventListener('submit', (e) => {
	e.preventDefault(); // 기본 동작 방지
	console.log("폼 제출");
});
```

# 이벤트 흐름

- **캡처링 단계 (Capturing Phase)**
    - 이벤트가 최상위 조상(window → document → html → body …)에서부터 실제 이벤트가 발생한 요소까지 내려가면서 전달되는 단계
    - 즉, 위에서 아래로 내려가는 흐름
- **타깃 단계 (Target Phase)**
    - 실제 이벤트가 발생한 요소에 도달하는 단계
    - 예) <button> 클릭 시 그 버튼이 타깃
- **버블링 단계 (Bubbling Phase)**
    - 이벤트가 타깃에서 시작해 다시 상위 요소로 거품처럼 위로 올라가는 단계
    - 예) button → div → body → html → document …

## 버블링 (Bubbling)

- **기본 동작**: 대부분의 이벤트는 버블링 단계에서 실행된다.
- 즉, 이벤트는 특정 요소에서 발생하면 그 부모, 조상 요소까지 차례로 올라가면서 이벤트 핸들러가 실행된다.
- 장점: 부모에 이벤트를 걸면 자식 여러 개를 한 번에 제어가 가능하다.

## 캡처링 (Capturing)

- 잘 쓰이진 않지만, 필요할 때는 활용할 수 있다.
- 이벤트 등록 시 **세 번째 인자**에 **{capture: true}**를 주면, 캡처링 단계에서 이벤트가 실행된다.

---

# 멀티쓰레드 기초

## 프로세스와 스레드

- **프로세스 (Process)**
    - 실행 중인 프로그램의 인스턴스
    - **독립적인 메모리 공간**을 보유한다. (코드, 데이터, 힙, 스택)
    - 다른 프로세스와 격리되어 실행된다.
    - 안정성은 높지만 리소스 관리가 비효율적이다.
    - 프로세스 간 통신(IPC)이 복잡하다.
    
    <img width="2991" height="1588" alt="Image" src="https://github.com/user-attachments/assets/c6b3af63-e6e1-4fa9-8bbb-94e947e7fa08" />
    
- **스레드 (Thread)**
    - 스레드는 프로세스 내에서 실제 작업을 수행하는 최소 단위이다.
    - 하나의 프로세스 안에는 여러 개의 스레드가 존재할 수 있다.
    - 프로세스의 리소스를 공유한다.
    - 독립적인 실행 흐름과 자신만의 스택을 보유한다.
    - **힙 메모리와 코드 영역은 공유**한다.
    
    <img width="2991" height="1588" alt="Image" src="https://github.com/user-attachments/assets/adb4f829-2be2-4cee-a50a-618f90f04e40" />
    

## 프로세스 vs 멀티스레드 비교

| **구분** | **프로세스** | **멀티스레드** |
| --- | --- | --- |
| **메모리** | 완전히 독립적 | 힙 영역 공유 |
| **통신** | IPC (복잡) | 메모리 공유 (간단) |
| **오버헤드** | 높음 | 낮음 |
| **안정성** | 높음 (격리됨) | 낮음 (오류 전파 가능) |
| **생성 비용** | 높음 | 낮음 |

## 멀티스레드 특징

- **장점**
    - **성능 향상**: 여러 작업을 동시에 처리
    - **자원 효율성**: 프로세스보다 적은 리소스 사용
    - **응답성 향상**: UI 애플리케이션에서 빠른 응답
- **단점 및 주의사항**
    - **동시성 문제**: 데이터 경쟁 상태(Race Condition) 발생 가능
    - **복잡성 증가**: 디버깅이 어려움
    - **데드락 위험**: 상호 대기로 인한 교착 상태

# 스레드 생성과 실행

## Thread 클래스 상속 방법

```java
public class MyThread extends Thread {
	@Override
	public void run() {
		// 스레드가 실행할 작업
		for (int i = 1; i <= 5; i++) {
			System.out.println(getName() + " 실행 중: " + i);
			try {
				Thread.sleep(1000); // 1초 대기
			} catch (InterruptedException e) {
				e.printStackTrace();
			}
		}
	}
	
	public static void main(String[] args) {
		System.out.println("메인 스레드 시작");
		
		MyThread thread1 = new MyThread();
		MyThread thread2 = new MyThread();
		
		thread1.setName("Thread-A");
		thread2.setName("Thread-B");
		
		thread1.start(); // 스레드 시작
		thread2.start();
		
		System.out.println("메인 스레드 종료");
	}
}

/* 실행 결과 예시
메인 스레드 시작
메인 스레드 종료
Thread-A 실행 중: 1
Thread-B 실행 중: 1
Thread-A 실행 중: 2
Thread-B 실행 중: 2
...
*/
```

- **장점**: 직관적이고 간단하다.
- **단점**: Java는 다중 상속이 불가하므로 `Thread`를 상속하면 다른 클래스 상속이 불가하다.
- `start()` : 새로운 스레드를 생성하고 내부적으로 `run()` 메서드 실행
- `run()` : 단순히 메서드를 호출 (새 스레드 생성 X)

## Runnable 인터페이스 구현 방법

```java
public class MyRunnable implements Runnable {
	private String taskName;
	
	public MyRunnable(String taskName) {
		this.taskName = taskName;
	}
	
	@Override
	public void run() {
		for (int i = 1; i <= 5; i++) {
			System.out.println(taskName + " 작업 중: " + i);
			try {
				Thread.sleep(500);
			} catch (InterruptedException e) {
				e.printStackTrace();
			}
		}
	}
	
	public static void main(String[] args) {
		// Runnable 객체 생성
		Runnable task1 = new MyRunnable("작업-1");
		Runnable task2 = new MyRunnable("작업-2");
		
		// Thread 객체에 전달
		Thread thread1 = new Thread(task1);
		Thread thread2 = new Thread(task2);
		
		thread1.start();
		thread2.start();
	}
}
```

- `Runnable`은 단순히 작업 내용(run 메서드)만 정의하고, 실행은 `Thread` 객체가 담당하므로 유연하다.

## 람다 표현식 활용

- Java 8부터 람다 표현식으로 간결하게 작성 가능
- `Runnable`은 함수형 인터페이스(추상 메서드가 1개만 존재)이므로 람다식 활용이 가능하다.
- 코드가 간결해지고 가독성이 향상된다.

```java
public class LambdaThreadExample {
	public static void main(String[] args) {
		// 람다 표현식으로 Runnable 구현
		Thread thread1 = new Thread(() -> {
			for (int i = 0; i < 5; i++) {
				System.out.println("람다 스레드: " + i);
				try {
					Thread.sleep(1000);
				} catch (InterruptedException e) {
					e.printStackTrace();
				}
			}
		});
		
		thread1.start();
	}
}
```

## Thread 클래스 vs Runnable 인터페이스

| **구분** | **Thread 상속** | **Runnable 구현** |
| --- | --- | --- |
| **다중 상속** | 불가능 | 가능 |
| **유연성** | 낮음 | 높음 |
| **코드 재사용성** | 낮음 | 높음 |
| **권장 사항** | 특별한 경우에만 사용 | 일반적으로 권장 |

# 스레드 동기화

## 동기화가 필요한 이유

- 여러 스레드가 공유 자원에 동시에 접근할 때 결과가 의도치 않게 꼬이게 되는 문제(**경쟁 상태**)가 발생한다.

```java
public class Counter {
	private int count = 0;
	
	// 동기화하지 않은 메서드 (문제 발생!!)
	public void increment() {
		count++; // 실제로는 3단계: 읽기 -> 증가 -> 쓰기
	}
	
	public int getCount() {
		return count;
	}
}
```

## Synchronized 키워드

- 한 번에 하나의 스레드만 코드 블록을 실행하도록 잠근다. (**lock**)
- Java는 내부적으로 *모니터 락(Monitor Lock)이라는 매커니즘을 사용한다.
    - 객체의 동기화를 관리하는 매커니즘을 의미한다.
    - 모니터는 객체애 대한 상호 배타적인 접근(mutex)을 보장한다.
- 동기화 단위: 메서드 동기화(메서드 전체에 락), 블록 동기화(특정 부분만 락 → 더 효율적)
- **메서드 동기화**
    
    ```java
    public class SynchronizedCounter {
    	private int count = 0;
    	
    	// 동기화된 메서드
    	public synchronized void increment() {
    		count++;
    	}
    	
    	public synchronized int getCount() {
    		return count;
    	}
    	
    	public static void main(String[] args) throws InterruptedException {
    		SynchronizedCounter counter = new SynchronizedCounter();
    		
    		// 10개 스레드가 각각 1000번씩 증가
    		Thread[] threads = new Thread[10];
    		
    		for (int i = 0; i < 10; i++) {
    			threads[i] = new Thread(() -> {
    				for (int j = 0; j < 1000; j++) {
    					counter.increment();
    				}
    			});
    			threads[i].start();
    		}
    		
    		// 모든 스레드 종료 대기
    		for (Thread thread : threads) {
    			thread.join();
    		}
    		
    		System.out.println("최종 카운트: " + counter.getCount()); // 10000
    	}
    }
    ```
    
- **블록 동기화**
    
    ```java
    public class BlockSynchronization {
    	private Object lock = new Object();
    	private int count = 0;
    	
    	public void increment() {
    		// 필요한 부분만 동기화
    		synchronized(lock) {
    			count++;
    		}
    	}
    }
    ```
    
    <img width="2079" height="1335" alt="Image" src="https://github.com/user-attachments/assets/60bb2e9b-da8a-4ea1-98ef-bc2c424d6478" />
    

## Deadlock (교착 상태)

- 두 개 이상의 스레드가 서로 자원을 기다리며 무한 대기 상태에 빠지는 것
- 예)
    - 스레드A가 자원1을 점유 → 자원2 필요
    - 스레드B가 자원2를 점유 → 자원1 필요
    - 서로 양보하지 않아서 멈춤
- 해결책: 락 획득 순서를 강제하거나, tryLock과 같은 타임아웃 기법 활용

## 스레드 실행 제어

| **메서드** | **설명** | **주의점** |
| --- | --- | --- |
| sleep(ms) | 일정 시간 동안 스레드 일시 정지 | InterruptedException 반드시 처리 필요 |
| join() | 다른 스레드가 끝날 때까지 대기 | 병렬 실행 후 결과 취합 시 유용 |
| interrupt() | 스레드기 대기/수면 상태를 깨움 (강제 종료 X) | 강제 종료 아님 → 스레드가 직접 확인 |
| setPriority() | 스레드 우선 순위 지정 (1 ~ 10) | 실제 반영 여부는 JVM/OS에 따라 다르다. |
| yield() | 실행 중인 스레드가 다른 스레드에게 CPU 양보 | 권장되지 않음 (운영체제 스케줄러에 의존) |
