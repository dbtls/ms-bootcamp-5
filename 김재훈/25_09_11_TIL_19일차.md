# 테이블 관계와 JOIN 개념

## JOIN이란?

- 하나 이상의 테이블로부터 연관된 데이터를 검색해 오는 방법이다.

## JOIN 종류

| **JOIN 종류** | **설명** |
| --- | --- |
| Cross Join | 모든 가능한 쌍이 나타난다. (Cartesian Product) |
| Inner Join | 조인 조건을 만족하는 튜플만 나타난다. |
| Outer Join | 조인 조건을 만족하지 않는 튜플도 null과 함께 나타난다. |
| Self Join | 자기 자신과 조인한다. |

# Cartesian Join (Cross Join)

## Cartesian Product

- 조인 조건이 없거나 잘못 기술된 경우 발생한다.
- 두 테이블을 그냥 곱해버려서 가능한 모든 조합을 만들어낸다.

```sql
-- 잘못된 조인 (조건 없음)
SELECT * FROM employees, departments;
-- 107명 * 27개 부서 = 2,889개 행
```

- 주의점
    - 의도하지 않은 대량의 데이터가 생성된다.
    - 크로스 조인 자체는 조건이 없어도 된다. (카사디안 곱 발생)
    - 카사디안 곱이 발생하지 않기 위해 반드시 WHERE 절에 조인 조건이 필요하다.
    - 위의 경우 최소 (조인 테이블 수 - 1)개의 조인 조건이 필요하다.

# Inner Join (EQUIJOIN)

- 조인 조건이 등호(=)로 이루어진 조인
- 보통 기본키 ↔ 외래키 관계에서 주로 사용된다.

## Simple Join

```sql
-- 전통적인 조인 방식
SELECT
	e.first_name,
	e.last_name,
	d.department_name
FROM
	employees e,
	departments d
WHERE
	e.department_id = d.department_id;
```

## ANSI JOIN 문법

```sql
-- JOIN ~ ON
SELECT
	e.first_name,
	e.last_name,
	d.department_name
FROM employees e
JOIN departments d ON e.department_id = d.department_id;

-- JOIN ~ USING (동일한 컬럼명일 때)
SELECT
	e.first_name,
	e.last_name,
	d.department_name
FROM employees e
JOIN departments d USING(department_id);

-- NATURAL JOIN (자동으로 같은 이름 컬럼 조인)
# 명시적이지 않아 예측하기 어렵고 유지보수성이 떨어진다.
SELECT * FROM employees NATURAL JOIN departments;
```

## 테이블 별칭(Alias) 사용

```sql
-- 별칭을 사용한 조인
SELECT
	e.employee_id AS 사원번호,
	e.first_name AS 이름,
	d.department_name AS 부서명,
	l.city AS 도시
FROM employees e
JOIN departments d ON e.department_id = d.department_id
JOIN locations l ON d.location_id = l.location_id;
```

## 추가 조건과 함께 사용

```sql
-- 조인 조건 + 추가 조건
SELECT
	e.first_name,
	e.salary,
	d.department_name
FROM employees e
JOIN departments d ON e.department_id = d.department_id
WHERE d.location_id = 1000
	AND e.salary >= 10000;
```

# Non-Equi Join(Theta Join)

- 조인 조건이 등호(=)가 아니라, 범위 조건(<, >, BETWEEN 등)을 사용하는 조인
- 테이블 간 값이 “같다”는 기준이 없고, 특정 범위나 조건에 따라 매칭

## 범위 조건 조인

```sql
-- salgrade 테이블이 있다고 가정
-- 급여 등급 조인
SELECT
	e.ename,
	e.sal,
	s.grade
FROM emp e, salgrade s
WHERE e.sal BETWEEN s.losal AND s.hisal;
```

# OUTER JOIN

- INNER JOIN과 다르게 조건에 맞지 않는 행도 포함시켜 누락 없이 가져오는 조인 방식
- 누락된 쪽의 컬럼 값은 NULL로 채워진다.
- Oracle에서는 데이터가 없는 쪽에 (+) 표기를 사용하는데 MySQL에서는 지원하지 않는다.
- MySQL에서는 LEFT OUTER JOIN / RIGHT OUTER JOIN을 사용해야 한다.

## LEFT OUTER JOIN

- 왼쪽 테이블의 모든 행이 결과에 포함된다.
- 즉, 왼쪽 테이블에 있는 값이 오른쪽 테이블에는 없더라도 출력하고 싶을 때 사용한다.

```sql
-- 부서가 없는 직원도 포함
SELECT
	e.employee_id,
	e.first_name,
	d.department_name
FROM employees e
LEFT OUTER JOIN departments d
ON e.department_id = d.department_id;

-- LEFT JOIN으로 축약 가능
SELECT
	e.employee_id,
	e.first_name,
	d.department_name
FROM employees e
LEFT JOIN departments d
ON e.department_id = d.department_id;
```

## RIGHT OUTER JOIN

- 오른쪽 테이블의 모든 행이 결과에 포함된다.
- 즉, 오른쪽 테이블에 있는 값이 왼쪽 테이블에는 없더라도 출력하고 싶을 때 사용한다.

```sql
-- 직원이 없는 부서도 포함
SELECT
	e.employee_id,
	e.first_name,
	d.department_name
FROM employees e
RIGHT OUTER JOIN departments d
ON e.department_id = d.department_id;
```

## FULL OUTER JOIN

- 양쪽 테이블의 모든 행이 결과에 포함된다.
- MySQL은 FULL OUTER JOIN을 직접 지원하지 않는다.
- 다른 DBMS와의 차이점
    - **PostgreSQL**, **SQL Server**, **Oracle**: FULL OUTER JOIN 직접 지원
    - **MySQL**: FULL OUTER JOIN 구문이 존재하지 않음
    - 해결방법: LEFT JOIN + RIGHT JOIN + UNION 사용
- MySQL에서 FULL OUTER JOIN 구현 방법
    
    ```sql
    SELECT
    	e.employee_id,
    	e.first_name,
    	d.department_name
    FROM employees e
    LEFT JOIN departments d ON e.department_id = d.department_id
    UNION
    SELECT
    	e.employee_id,
    	e.first_name,
    	d.department_name
    FROM employees e
    RIGHT JOIN departments d ON e.department_id = d.department_id
    # 중복 제거를 위해 추가 (UNION은 기본적으로 중복을 제거하므로, 여기서 필수는 아니다)
    WHERE e.department_id IS NULL;
    ```
    
- 다른 DBMS에서 FULL OUTER JOIN 사용
    
    ```sql
    -- PostgreSQL, SQL Server, Oracle에서 가능한 구문
    SELECT
    	e.employee_id,
    	e.first_name,
    	d.department_name
    FROM employees e
    FULL OUTER JOIN departments d
    ON e.department_id = d.department_id;
    ```
    
- FULL OUTER JOIN 사용 시점
    - 양쪽 테이블의 모든 데이터를 보고 싶을 때
    - 누락된 매칭 관계를 찾아낼 때
    - 데이터 완전성 검사를 할 때

# SELF JOIN

- 한 테이블을 자기 자신과 조인하는 방식
- 테이블에 상하 관계(직원 ↔ 관리자, 카테고리 ↔ 상위 카테고리 등)가 있을 경우 주로 사용한다.

## 자기 자신과 조인

```sql
-- 직원과 상사 정보 조회
SELECT
	e.employee_id AS 사원ID,
	e.first_name AS 사원이름,
	m.employee_id AS 상사ID,
	m.first_name AS 상사이름,
FROM employees e
JOIN employees m ON e.manager_id = m.employee_id;
```

## SELF LEFT OUTER JOIN

```sql
-- 상사가 없는 사람(최고 경영자)도 포함
SELECT
	e.employee_id AS 사원ID,
	e.first_name AS 사원이름,
	m.employee_id AS 상사ID,
	m.first_name AS 상사이름
FROM employees e
LEFT JOIN employees m ON e.manager_id = m.employee_id;
```

# JOIN 정리

- **INNER JOIN (EQUIJOIN)**
    - 조인 조건이 등호(=)로 이루어진 조인
- **NON-EQUI JOIN**
    - 조인 조건이 등호(=)가 아니라, 범위 조건(<, >, BETWEEN 등)을 사용하는 조인
- **OUTER JOIN**
    - INNER JOIN과 다르게 조건에 맞지 않는 행도 포함시켜 누락 없이 가져오는 조인 방식
    - LEFT OUTER JOIN
        - 왼쪽 테이블의 모든 행이 결과에 포함된다.
        - 즉, 왼쪽 테이블에 있는 값이 오른쪽에 없더라도 출력하고 싶다.
    - RIGHT OUTER JOIN
        - 오른쪽 테이블의 모든 행이 결과에 포함된다.
        - 즉, 오른쪽 테이블에 있는 값이 오른쪽에 없더라도 출력하고 싶다.
    - FULL OUTER JOIN
        - 양쪽 테이블의 모든 행이 결과에 포함된다.
        - 다만 MySQL은 FULL OUTER JOIN을 직접 지원하지 않는다.
- **SELF JOIN**
    - 한 테이블을 자기 자신과 조인하는 방식

# 서브쿼리(SubQuery)

## 서브쿼리란?

- 하나의 SQL 질의문 속에 다른 SQL 질의문이 포함되어 있는 형태
- GROUP BY 절을 제외하고 모든 부분에서 사용이 가능하며, 반드시 괄호 안에 포함되어야 한다.

```sql
-- SCOTT의 급여보다 높은 급여를 받는 사람
SELECT ename
FROM emp
WHERE sal > (
	SELECT sal
	FROM emp
	WHERE ename = 'SCOTT'
);
```

## Single-Row Subquery

- 서브쿼리의 결과가 한 행인 경우

```sql
-- 평균 급여보다 적은 급여를 받는 사람
SELECT ename, sal
FROM emp
WHERE sal < (
	SELECT AVG(sal)
	FROM emp
);

-- 가장 먼저 입사한 사원
SELECT ename, hiredate
FROM emp
WHERE hiredate = (
	SELECT MIN(hiredate)
	FROM emp
);
```

## Multi-Row Subquery

- 서브쿼리의 결과가 여러 행인 경우
- 서브쿼리의 결과가 여러개이므로, >, =, < 등의 연산자 수행이 되지 않는다.

```sql
-- IN 연산자 사용 -> OR의 결합 (value = first_row OR second_row OR ...)
SELECT ename, sal, deptno
FROM emp
WHERE deptno IN (
	SELECT deptno
	FROM dept
	WHERE loc IN ('NEW YORK', 'DALLAS')
);

-- ANY 연산자 사용 -> OR 결합
SELECT ename, sal
FROM emp
WHERE sal > ANY (
	SELECT sal
	FROM emp
	WHERE deptno = 30
);
# = ANY -> IN과 동일하다.
# > ANY -> 최소값보다 크다 (>= 크거나 같다)
# < ANY -> 최대값보다 작다 (<= 작거나 같다)

-- ALL 연산자 사용
SELECT ename, sal
FROM emp
WHERE sal > ALL (
	SELECT sal
	FROM emp
	WHERE deptno = 30
);
# = ALL -> 값이 하나가 아니면 오류가 발생한다.
# > ALL -> 최대값보다 크다 (>= 크거나 같다)
# < ALL -> 최소값보다 작다 (<= 작거나 같다)
```

# 상관 서브쿼리 (Correlated Subquery)

## 상관 서브쿼리 개념

- 외부 쿼리와 내부 쿼리가 서로 연관되어 있는 서브쿼리
- 서브쿼리가 메인쿼리의 각 행 값을 참조하기 때문에, 메인 쿼리의 행마다 반복 실행된다.
- 실행순서: 메인쿼리 한 행 → 서브쿼리 실행 → 조건 확인 → 다음 행 반복

```sql
-- 자신이 속한 부서의 평균 급여보다 많이 받는 사람
SELECT o.ename, o.sal, o.deptno
FROM emp o
WHERE o.sal > (
	SELECT AVG(i.sal)
	FROM emp i
	WHERE i.deptno = o.deptno
);
```

## EXISTS 연산자

- 서브쿼리 결과의 존재 여부만 확인하는 연산자로, select 1로 주로 사용한다.
- 서브쿼리에 행이 하나라도 있으면 true, 없으면 false를 반환한다.

```sql
-- 부하직원이 있는 직원만 조회
SELECT e.employee_id, e.first_name
FROM employees e
WHERE EXISTS (
	SELECT 1
	FROM employees s
	WHERE s.manager_id = e.employee_id
);

-- 부하직원이 없는 직원
SELECT e.employee_id, e.first_name
FROM employees e
WHERE NOT EXISTS (
	SELECT 1
	FROM employees s
	WHERE s.manager_id = e.employee_id
);
```

## 다중 컬럼 서브쿼리

```sql
-- 각 부서별 최고 급여를 받는 사람
SELECT deptno, empno, ename, sal
FROM emp
WHERE (deptno, sal) IN (
	SELECT deptno, MAX(sal)
	FROM emp
	GROUP BY deptno
);
```

# 집합 연산자 (Set Operators)

## 테스트 테이블 생성

```sql
-- 테스트용 테이블
CREATE TABLE A (name INT);
CREATE TABLE B (name INT);

INSERT INTO A VALUES (1), (2), (3);
INSERT INTO B VALUES (2), (3), (4);
```

## UNION

- 중복을 제거한 합집합

```sql
SELECT name FROM A
UNION
SELECT name FROM B
-- 결과: 1, 2, 3, 4
```

<img width="765" height="213" alt="Image" src="https://github.com/user-attachments/assets/8a55c688-8281-4696-a17e-bfc0e0f5f03b" />

## UNION ALL

- 중복을 포함한 합집합

```sql
SELECT name FROM A
UNION ALL
SELECT name FROM B;
-- 결과: 1, 2, 3, 2, 3, 4
```

<img width="759" height="213" alt="Image" src="https://github.com/user-attachments/assets/87637736-3bd2-431a-9f8a-a77d1b1c5e7d" />

## INTERSECT (교집합)

- MySQL은 직접 지원하지 않으므로 JOIN으로 구현한다.

```sql
-- INTERSECT 대체
SELECT DISTINCT A.name
FROM A
INNER JOIN B ON A.name = B.name;
-- 결과: 2, 3
```

<img width="762" height="242" alt="Image" src="https://github.com/user-attachments/assets/21df0658-70cc-4557-8711-f94b5ff668b6" />

## MINUS (차집합)

- MySQL은 직접 지원하지 않으므로 서브쿼리로 구현한다.

```sql
-- MINUS 대체
SELECT name FROM A
WHERE name NOT IN (
	SELECT name FROM B
);
-- 결과: 1
```

<img width="758" height="236" alt="Image" src="https://github.com/user-attachments/assets/856c796b-9df5-422c-afd0-af99b81050d2" />

# 윈도우 함수 (Window Functions)

## RANK() 함수

- MySQL 8.0 이상에서 사용 가능
- OVER 부분에서 순위 부여 기준을 정한다.

```sql
-- 급여 순위 매기기
SELECT
	sal,
	ename,
	RANK() OVER(ORDER BY sal DESC) AS ranking
FROM emp;

-- 부서별 급여 순위
SELECT
	deptno,
	ename,
	sal,
	RANK() OVER(PARTITION BY deptno ORDER BY sal DESC) AS dept_rank
FROM emp;
```

## ROW_NUMBER()

```sql
-- 행 번호 부여
SELECT
	ROW_NUMBER() OVER(ORDER BY sal DESC) AS row_num,
	ename,
	sal
FROM emp;
```

## DENSE_RANK()

- 동순위를 건너뛰지 않는다.

```sql
-- 동일 순위 다음 순위 건너뛰지 않음
SELECT
	sal,
	ename,
	DENSE_RANK() OVER(ORDER BY sal DESC) AS dense-ranking
FROM emp;
```

---

# DDL (Data Definition Language)

## DDL 개요

| **SQL 분류** | **명령어** | **설명** |
| --- | --- | --- |
| DDL | CREATE, ALTER, DROP, TRUNCATE | 구조 정의 |
| DML | INSERT, UPDATE, DELETE, SELECT | 데이터 조작 |
| DCL | GRANT, REVOKE | 권한 제어 |
| TCL | COMMIT, ROLLBACK | 트랜잭션 제어 |

## DDL 명령어 요약

- **CREATE TABLE** : 테이블 생성
- **ALTER TABLE** : 테이블 구조 변경
- **DROP TABLE** : 테이블 삭제
- **RENAME** : 이름 변경
- **TRUNCATE** : 테이블의 모든 데이터 삭제
- **COMMENT** : 테이블에 설명 추가

# MySQL 데이터 타입

## 주요 데이터 타입

| **분류** | **타입** | **설명** |
| --- | --- | --- |
| 숫자형 | INT, BIGINT, DECIMAL | 정수, 실수 |
| 문자형 | VARCHAR, CHAR, TEXT | 문자열 |
| 날짜형 | DATE, TIME, DATETIME, TIMESTAMP | 날짜와 시간 |
| 기타 | JSON, BLOB | JSON 데이터, 바이너리 |

## 타입 선택 가이드

```sql
-- 숫자형
INT             -- -2,147,483,648 ~ 2,147,483,647
BIGINT          -- 더 큰 정수
DECIMAL(8,2)    -- 전체 8자리, 소수점 2자리

-- 문자형
VARCHAR(255)    -- 가변 길이 (최대 255)
CHAR(10)        -- 고정 길이 (정확히 10)
TEXT            -- 긴 텍스트

-- 날짜형
DATE            -- 'YYYY-MM-DD'
DATETIME        -- 'YYYY-MM-DD HH:MM:SS'
TIMESTAMP       -- 자동 시간 기록
```

# CREATE TABLE

## 기본 문법

```sql
CREATE TABLE 테이블이름 (
	필드이름1 필드타입1 [제약조건],
	필드이름2 필드타입2 [제약조건],
	...
	[테이블 제약조건]
);
```

- 테이블 이름은 복수를 사용하는 것이 일반적이다.

## 제약조건 (Constraints)

| **제약조건** | **설명** |
| --- | --- |
| NOT NULL | NULL을 허용하지 않는다. |
| UNIQUE | 중복된 값을 허용하지 않는다. |
| PRIMARY KEY | NOT NULL + UNIQUE |
| FOREIGN KEY | 다른 테이블 참조 |
| DEFAULT | 기본값을 설정한다. |
| CHECK | 값의 범위를 제한한다. |
| AUTO_INCREMENT | 자동으로 증가한다. |
- CHECK 제약조건 주의사항
    - MySQL 8.0.16 이전 버전에서는 CHECK 제약조건이 파싱은 되지만 실제로 작동하지 않는다.
    - MySQL 8.0.16 이후부터 CHECK 제약조건이 완전히 지원된다.

## 테이블 생성 예제

```sql
-- 학생(id, name, age, email, created_date)
CREATE TABLE students (
	id int primary key auto_increment, # 기본키 (반드시 설정해야 한다.)
    name varchar(50) NOT NULL,
    age int,
    email varchar(100) UNIQUE,
    created_date DATETIME DEFAULT current_timestamp
);
# DATETIME은 TIMEZONE을 가지고 있지 않고, TIMESTAMP는 TIMEZONE을 가지고 있다.
```

# INSERT INTO

- 데이터를 삽입할 때 사용한다.
- 기본 문법
    
    ```sql
    INSERT INTO 테이블명 (컬럼명..) VALUES (값..)
    # 컬럼이 나열된 순서대로 값이 나열되어야 한다.
    INSERT INTO 테이블명 VALUES (값..)
    # 컬럼명을 생략할 경우, 테이블에 존재하는 모든 컬럼에 대해 순서대로 값이 나열되어야 한다.
    ```
    
- 예제
    
    ```sql
    INSERT INTO students (name, age) VALUES ('jaehun', 20);
    INSERT INTO students (name, age) VALUES (20);
    # 오류 발생: name은 NOT NULL로 설정되어 있기 때문에 NULL 값이 들어가면 오류가 발생한다.
    INSERT INTO students VALUES ('jaehun', 20);
    # 오류 발생: 컬럼명을 생략할 경우, 테이블에 존재하는 모든 컬럼에 대해 순서대로 값이 나열되어야 한다.
    ```
