# Connection, PreparedStatement, ResultSet

- **Connection (DB 연결)**
    - `DriverManager.getConnection(url, user, password)`
    - DB와 자바 프로그램을 연결하는 통로이다.
- **PreparedStatement (SQL 준비)**
    - `PreparedStatement ps = conn.prepareStatement(sql)`
    - `?`를 사용해 변수 바인딩 처리가 가능하다. → SQL Injection을 방지한다.
- **SQL 실행**
    - `executeQuery()`
        - SELECT (조회) 전용
        - 결과는 반드시 ResultSet으로 반환한다.
    - `executeUpdate()`
        - INSERT/UPDATE/DELETE (변경)
        - 결과는 변경된 행 수(int)를 반환한다.
        - 대량 변경이라면 `executeLargeUpdate()` (long 반환)을 고려하자.
    - `execute()`
        - 결과가 있을 수도/없을 수도 있을 때 사용한다.
        - 아주 드물게 사용하며, 권장되지 않는 방법이다.
- **ResultSet (결과 처리)**
    - `rs.next()`로 한 줄씩 이동한다.
    - `rs.getString(”컬럼명")`, `rs.getInt(”컬럼명”)`으로 값을 꺼낼 수 있다.
- **리소스 해제**
    - `rs.close()`, `ps.close()`, `conn.close()`
    - Java 7+ `try-with-resources`로 자동 닫기 가능

# CRUD

## 예제

```java
// CREATE (INSERT)
String sql = "INSERT INTO user (name, age) VALUES (?, ?)";
PreparedStatement ps = conn.prepareStatement(sql);
ps.setString(1, "홍길동");
ps.setInt(2, 20);
int rows = ps.executeUpdate(); // 삽입된 행 수 반환

// READ (SELECT)
String sql = "SELECT * FROM user WHERE user_id = ?";
PreparedStatement ps = conn.prepareStatement(sql);
ps.setInt(1, 1);
ResultSet rs = ps.executeQuery();
if (rs.next()) {
	System.out.println(rs.getString("name"));
}

// UPDATE
// try-with-resources 사용 -> 권장
String sql = "UPDATE user SET name = ? WHERE user_id = ?";
try (Connection conn = DriverManager.getConnection(url, user, password);
		PreparedStatement ps = conn.prepareStatement(sql)) {
	
	ps.setString(1, "김철수");
	ps.setInt(2, 1);
	ps.executeUpdate();

} catch (SQLException e) {
	System.out.println(e.getMessage());
}

// DELETE
// try-with-resources 사용 -> 권장
String sql = "DELETE FROM user WHERE user_id = ?";
try (Connection conn = DriverManager.getConnection(url, user, password);
		PreparedStatement ps = conn.prepareStatement(sql)) {
	
	ps.setInt(1, 1);
	ps.executeUpdate();

} catch (SQLException e) {
	System.out.println(e.getMessage());
}
```

# 레이어드 아키텍처

- 소프트웨어를 여러 계층(Layer)으로 나누어 설계하는 아키텍처 패턴이다.
- 관심사의 분리 원칙을 가장 잘 실현한 구조 중 하나이다.
- JDBC 코드를 그냥 쓰면 비즈니스 로직과 SQL 코드가 뒤섞여서 유지보수가 힘들다.
- 유지보수성, 확장성, 테스트 용이성을 높이기 위해 널리 사용된다.
- 일반적으로 **4계층**으로 구성된다.
    - Presentation Layer (UI/Controller)
        - 사용자와 직접적으로 상호작용
        - 서비스 호출 후 결과를 화면에 전달
        - DB 관련 코드 X
    - Service Layer (Business Logic)
        - 핵심 비즈니스 로직을 수행하고, 트랜잭션을 관리
        - 컨트롤러와 DAO 사이의 중간 처리
        - 여러 DAO를 조합해 동작 수행
    - Persistence Layer (Repository/DAO)
        - 실제 SQL 실행(INSERT/SELECT/UPDATE/DELETE)
        - 데이터베이스와 직접적인 연결을 통해 CRUD 작업 수행
    - Domain Layer (Entity/DTO)
        - 애플리케이션의 핵심 비즈니스 객체
        - 데이터의 구조를 정의하는 클래스
- 각 계층은 자신보다 하위 계층에만 의존하며, 상위 계층은 하위 계층의 구현에 대해 알지 못하는 것이 원칙

```bash
DTO (Getter, Setter)
 |
Service -- Controller -- User
 |
DAO (CRUD)
 |
DB
```

# 트랜잭션

- 하나의 논리적 작업 단위를 묶어서 처리하는 것이다.
- 둘 중 하나라도 실패하면 전체 취소해야 한다. → **Rollback**
- 트랜잭션 처리는 서비스 레이어에서 처리한다.

# 커넥션 풀

- DB 연결(Connection) 객체를 미리 여러 개 만들어두고 재사용하는 방식이다.
- 새로 열고 닫는 비용이 크기 때문에 성능이 향상된다.
- HikariCP
- 장점
    - 현재 가장 빠르고 가벼운 JDBC Connection Pool 라이브러리이다.
    - 가장 빠른 성능과 적은 메모리 사용량
    - Spring Boot 2.0부터 기본 Connection Pool
    - 간단한 설정
